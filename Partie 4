# -*- coding: utf-8 -*-
"""Nintendo - Option pricing.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EtGxPnckwLWK-mOxy91Cr0iEpA-WaIph

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    OPTION PRICING STRATEGIES FOR NINTENDO (NTDOY)
    PÃ©riode: Septembre 2015 - Septembre 2025

    Options Ã©valuÃ©es:
    1. Options EuropÃ©ennes (Black-Scholes-Merton)
    2. Options AmÃ©ricaines (Binomial Tree)
    3. Options BermudÃ©ennes (Binomial Tree modifiÃ©)
    4. Options Exotiques - Asiatiques (Monte Carlo)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
""
"""

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 1: IMPORTS ET CONFIGURATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.stats import norm
from datetime import datetime
import warnings
warnings.filterwarnings('ignore')

# Configuration des graphiques
plt.style.use('seaborn-v0_8-whitegrid')
sns.set_palette("Set2")
plt.rcParams['figure.figsize'] = (14, 8)
plt.rcParams['font.size'] = 11

print("=" * 80)
print("  OPTION PRICING STRATEGIES - NINTENDO (NTDOY)")
print("=" * 80)
print()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 2: RÃ‰CUPÃ‰RATION ET ANALYSE DES DONNÃ‰ES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("ğŸ“¥ TÃ©lÃ©chargement des donnÃ©es Nintendo...")

ticker = "NTDOY"
start_date = "2015-09-01"
end_date = "2025-09-30"

# TÃ©lÃ©chargement des donnÃ©es
nintendo = yf.download(ticker, start=start_date, end=end_date)
prices = nintendo['Close'].dropna()

# Calcul des paramÃ¨tres du marchÃ©
log_returns = np.log(prices / prices.shift(1)).dropna()
current_price = prices.iloc[-1].item() # Extract scalar value
volatility = log_returns.std().item() * np.sqrt(252)  # VolatilitÃ© annualisÃ©e
mean_return = log_returns.mean().item() * 252  # Rendement moyen annualisÃ©

print(f"âœ… Analyse des donnÃ©es Nintendo:")
print(f"   - Prix actuel (Sâ‚€): ${current_price:.2f}")
print(f"   - VolatilitÃ© annualisÃ©e (Ïƒ): {volatility:.4f} ({volatility*100:.2f}%)")
print(f"   - Rendement moyen annualisÃ© (Î¼): {mean_return:.4f} ({mean_return*100:.2f}%)")
print(f"   - PÃ©riode d'analyse: {len(prices)} jours de trading")
print()

# ParamÃ¨tres des options
strike_price = current_price  # At-the-money (ATM)
time_to_maturity = 1.0  # 1 an
risk_free_rate = 0.045  # Taux sans risque ~4.5% (Ã  ajuster selon le marchÃ© actuel)

print(f"ğŸ“‹ PARAMÃˆTRES DES OPTIONS:")
print(f"   - Prix d'exercice (K): ${strike_price:.2f} (At-The-Money)")
print(f"   - MaturitÃ© (T): {time_to_maturity} an(s)")
print(f"   - Taux sans risque (r): {risk_free_rate:.3f} ({risk_free_rate*100:.1f}%)")
print()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 3: OPTIONS EUROPÃ‰ENNES - BLACK-SCHOLES-MERTON
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("=" * 80)
print("  OPTION 1: OPTIONS EUROPÃ‰ENNES (Black-Scholes-Merton)")
print("=" * 80)
print()

def black_scholes_european(S, K, T, r, sigma, option_type='call'):
    """
    Calcul du prix d'une option europÃ©enne par Black-Scholes-Merton

    ParamÃ¨tres:
        S: Prix actuel de l'actif
        K: Prix d'exercice
        T: Temps jusqu'Ã  maturitÃ© (annÃ©es)
        r: Taux sans risque
        sigma: VolatilitÃ©
        option_type: 'call' ou 'put'

    Retourne:
        Prix de l'option
    """
    d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)

    if option_type == 'call':
        price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)
    else:  # put
        price = K * np.exp(-r * T) * norm.cdf(-d2) - S * norm.cdf(-d1)

    return price

# Calcul des prix des options europÃ©ennes
european_call = black_scholes_european(
    current_price, strike_price, time_to_maturity,
    risk_free_rate, volatility, 'call'
)

european_put = black_scholes_european(
    current_price, strike_price, time_to_maturity,
    risk_free_rate, volatility, 'put'
)

print("ğŸ“Š PRIX DES OPTIONS EUROPÃ‰ENNES:")
print("-" * 80)
print(f"{'Type Option':<30} {'Prix':<20} {'% du Spot':<20}")
print("-" * 80)
print(f"{'Call EuropÃ©en':<30} ${european_call:<19.4f} {european_call/current_price*100:<19.2f}%")
print(f"{'Put EuropÃ©en':<30} ${european_put:<19.4f} {european_put/current_price*100:<19.2f}%")
print("-" * 80)
print()

# VÃ©rification de la paritÃ© Put-Call
put_call_parity_check = european_call - european_put - (current_price - strike_price * np.exp(-risk_free_rate * time_to_maturity))
print(f"âœ… VÃ©rification ParitÃ© Put-Call: {abs(put_call_parity_check):.10f} (doit Ãªtre â‰ˆ 0)")
print()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 4: OPTIONS AMÃ‰RICAINES - BINOMIAL TREE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("=" * 80)
print("  OPTION 2: OPTIONS AMÃ‰RICAINES (Binomial Tree)")
print("=" * 80)
print()

def binomial_tree_american(S, K, T, r, sigma, N, option_type='call'):
    """
    Calcul du prix d'une option amÃ©ricaine par arbre binomial

    ParamÃ¨tres:
        S: Prix actuel de l'actif
        K: Prix d'exercice
        T: Temps jusqu'Ã  maturitÃ© (annÃ©es)
        r: Taux sans risque
        sigma: VolatilitÃ©
        N: Nombre de pas dans l'arbre
        option_type: 'call' ou 'put'

    Retourne:
        Prix de l'option
    """
    dt = T / N
    u = np.exp(sigma * np.sqrt(dt))  # Facteur de hausse
    d = 1 / u  # Facteur de baisse
    p = (np.exp(r * dt) - d) / (u - d)  # ProbabilitÃ© risque-neutre

    # Initialisation de l'arbre des prix
    price_tree = np.zeros((N + 1, N + 1))

    # Prix Ã  maturitÃ©
    for i in range(N + 1):
        price_tree[i, N] = S * (u ** (N - i)) * (d ** i)

    # Valeurs de l'option Ã  maturitÃ©
    option_tree = np.zeros((N + 1, N + 1))

    for i in range(N + 1):
        if option_type == 'call':
            option_tree[i, N] = max(0, price_tree[i, N] - K)
        else:  # put
            option_tree[i, N] = max(0, K - price_tree[i, N])

    # Backward induction
    for j in range(N - 1, -1, -1):
        for i in range(j + 1):
            price_tree[i, j] = S * (u ** (j - i)) * (d ** i)

            # Valeur de continuation
            continuation_value = np.exp(-r * dt) * (
                p * option_tree[i, j + 1] + (1 - p) * option_tree[i + 1, j + 1]
            )

            # Valeur d'exercice immÃ©diat
            if option_type == 'call':
                exercise_value = max(0, price_tree[i, j] - K)
            else:  # put
                exercise_value = max(0, K - price_tree[i, j])

            # Pour les options amÃ©ricaines: max(continuation, exercice)
            option_tree[i, j] = max(continuation_value, exercise_value)

    return option_tree[0, 0]

# Nombre de pas dans l'arbre binomial
N_steps = 100

print(f"ğŸŒ³ Arbre binomial avec {N_steps} pas")
print()

# Calcul des prix des options amÃ©ricaines
american_call = binomial_tree_american(
    current_price, strike_price, time_to_maturity,
    risk_free_rate, volatility, N_steps, 'call'
)

american_put = binomial_tree_american(
    current_price, strike_price, time_to_maturity,
    risk_free_rate, volatility, N_steps, 'put'
)

print("ğŸ“Š PRIX DES OPTIONS AMÃ‰RICAINES:")
print("-" * 80)
print(f"{'Type Option':<30} {'Prix':<20} {'% du Spot':<20}")
print("-" * 80)
print(f"{'Call AmÃ©ricain':<30} ${american_call:<19.4f} {american_call/current_price*100:<19.2f}%")
print(f"{'Put AmÃ©ricain':<30} ${american_put:<19.4f} {american_put/current_price*100:<19.2f}%")
print("-" * 80)
print()

# Prime d'exercice anticipÃ©
early_exercise_premium_call = american_call - european_call
early_exercise_premium_put = american_put - european_put

print("ğŸ’° PRIME D'EXERCICE ANTICIPÃ‰:")
print(f"   - Call: ${early_exercise_premium_call:.4f} ({early_exercise_premium_call/european_call*100:.2f}%)")
print(f"   - Put: ${early_exercise_premium_put:.4f} ({early_exercise_premium_put/european_put*100:.2f}%)")
print()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 5: OPTIONS BERMUDÃ‰ENNES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("=" * 80)
print("  OPTION 3: OPTIONS BERMUDÃ‰ENNES (Binomial Tree modifiÃ©)")
print("=" * 80)
print()

def binomial_tree_bermudan(S, K, T, r, sigma, N, exercise_dates, option_type='call'):
    """
    Calcul du prix d'une option bermudÃ©enne par arbre binomial

    Les options bermudÃ©ennes peuvent Ãªtre exercÃ©es uniquement Ã  des dates spÃ©cifiques

    ParamÃ¨tres:
        S: Prix actuel de l'actif
        K: Prix d'exercice
        T: Temps jusqu'Ã  maturitÃ© (annÃ©es)
        r: Taux sans risque
        sigma: VolatilitÃ©
        N: Nombre de pas dans l'arbre
        exercise_dates: Liste des dates d'exercice possibles (en fraction de T)
        option_type: 'call' ou 'put'

    Retourne:
        Prix de l'option
    """
    dt = T / N
    u = np.exp(sigma * np.sqrt(dt))
    d = 1 / u
    p = (np.exp(r * dt) - d) / (u - d)

    # Conversion des dates d'exercice en indices
    exercise_indices = [int(date * N) for date in exercise_dates]
    exercise_indices.append(N)  # On peut toujours exercer Ã  maturitÃ©

    # Initialisation
    price_tree = np.zeros((N + 1, N + 1))
    option_tree = np.zeros((N + 1, N + 1))

    # Prix Ã  maturitÃ©
    for i in range(N + 1):
        price_tree[i, N] = S * (u ** (N - i)) * (d ** i)
        if option_type == 'call':
            option_tree[i, N] = max(0, price_tree[i, N] - K)
        else:
            option_tree[i, N] = max(0, K - price_tree[i, N])

    # Backward induction
    for j in range(N - 1, -1, -1):
        for i in range(j + 1):
            price_tree[i, j] = S * (u ** (j - i)) * (d ** i)

            # Valeur de continuation
            continuation_value = np.exp(-r * dt) * (
                p * option_tree[i, j + 1] + (1 - p) * option_tree[i + 1, j + 1]
            )

            # Valeur d'exercice
            if option_type == 'call':
                exercise_value = max(0, price_tree[i, j] - K)
            else:
                exercise_value = max(0, K - price_tree[i, j])

            # Si c'est une date d'exercice possible, on prend le max
            if j in exercise_indices:
                option_tree[i, j] = max(continuation_value, exercise_value)
            else:
                option_tree[i, j] = continuation_value

    return option_tree[0, 0]

# Dates d'exercice possibles (trimestriellement: 0.25, 0.5, 0.75, 1.0)
exercise_dates = [0.25, 0.5, 0.75]

print(f"ğŸ“… Dates d'exercice possibles: trimestres {[f'{d*12:.0f} mois' for d in exercise_dates]} + maturitÃ©")
print()

# Calcul des prix des options bermudÃ©ennes
bermudan_call = binomial_tree_bermudan(
    current_price, strike_price, time_to_maturity,
    risk_free_rate, volatility, N_steps, exercise_dates, 'call'
)

bermudan_put = binomial_tree_bermudan(
    current_price, strike_price, time_to_maturity,
    risk_free_rate, volatility, N_steps, exercise_dates, 'put'
)

print("ğŸ“Š PRIX DES OPTIONS BERMUDÃ‰ENNES:")
print("-" * 80)
print(f"{'Type Option':<30} {'Prix':<20} {'% du Spot':<20}")
print("-" * 80)
print(f"{'Call BermudÃ©en':<30} ${bermudan_call:<19.4f} {bermudan_call/current_price*100:<19.2f}%")
print(f"{'Put BermudÃ©en':<30} ${bermudan_put:<19.4f} {bermudan_put/current_price*100:<19.2f}%")
print("-" * 80)
print()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 6: OPTIONS ASIATIQUES - MONTE CARLO
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("=" * 80)
print("  OPTION 4: OPTIONS EXOTIQUES - ASIATIQUES (Monte Carlo)")
print("=" * 80)
print()

def asian_option_monte_carlo(S, K, T, r, sigma, N_steps, N_sims, option_type='call'):
    """
    Calcul du prix d'une option asiatique par Monte Carlo

    L'option asiatique dÃ©pend du prix moyen de l'actif pendant la durÃ©e de vie de l'option

    ParamÃ¨tres:
        S: Prix actuel de l'actif
        K: Prix d'exercice
        T: Temps jusqu'Ã  maturitÃ© (annÃ©es)
        r: Taux sans risque
        sigma: VolatilitÃ©
        N_steps: Nombre de pas de temps dans la simulation
        N_sims: Nombre de simulations Monte Carlo
        option_type: 'call' ou 'put'

    Retourne:
        Prix de l'option
    """
    dt = T / N_steps
    discount_factor = np.exp(-r * T)

    # Simulations des trajectoires de prix
    payoffs = np.zeros(N_sims)

    for sim in range(N_sims):
        # GÃ©nÃ©ration d'une trajectoire
        prices = np.zeros(N_steps + 1)
        prices[0] = S

        for t in range(1, N_steps + 1):
            z = np.random.standard_normal()
            prices[t] = prices[t-1] * np.exp(
                (r - 0.5 * sigma**2) * dt + sigma * np.sqrt(dt) * z
            )

        # Prix moyen arithmÃ©tique
        average_price = np.mean(prices)

        # Payoff
        if option_type == 'call':
            payoffs[sim] = max(0, average_price - K)
        else:  # put
            payoffs[sim] = max(0, K - average_price)

    # Prix de l'option
    option_price = discount_factor * np.mean(payoffs)
    std_error = discount_factor * np.std(payoffs) / np.sqrt(N_sims)

    return option_price, std_error

# ParamÃ¨tres Monte Carlo
N_mc_steps = 252  # Une observation par jour de trading
N_simulations = 10000

print(f"ğŸ² Simulation Monte Carlo:")
print(f"   - Nombre de simulations: {N_simulations:,}")
print(f"   - Pas de temps: {N_mc_steps}")
print()

# Seed pour reproductibilitÃ©
np.random.seed(42)

# Calcul des prix des options asiatiques
asian_call, asian_call_se = asian_option_monte_carlo(
    current_price, strike_price, time_to_maturity,
    risk_free_rate, volatility, N_mc_steps, N_simulations, 'call'
)

asian_put, asian_put_se = asian_option_monte_carlo(
    current_price, strike_price, time_to_maturity,
    risk_free_rate, volatility, N_mc_steps, N_simulations, 'put'
)

print("ğŸ“Š PRIX DES OPTIONS ASIATIQUES:")
print("-" * 80)
print(f"{'Type Option':<30} {'Prix':<20} {'Ã‰cart-type':<20}")
print("-" * 80)
print(f"{'Call Asiatique':<30} ${asian_call:<19.4f} Â±${asian_call_se:<19.6f}")
print(f"{'Put Asiatique':<30} ${asian_put:<19.4f} Â±${asian_put_se:<19.6f}")
print("-" * 80)
print()

# Intervalle de confiance 95%
print("ğŸ“ˆ INTERVALLES DE CONFIANCE (95%):")
print(f"   - Call: ${asian_call - 1.96*asian_call_se:.4f} - ${asian_call + 1.96*asian_call_se:.4f}")
print(f"   - Put: ${asian_put - 1.96*asian_put_se:.4f} - ${asian_put + 1.96*asian_put_se:.4f}")
print()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 7: COMPARAISON GLOBALE DES PRIX
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("=" * 80)
print("  COMPARAISON GLOBALE DES PRIX D'OPTIONS")
print("=" * 80)
print()

# CrÃ©ation du DataFrame de comparaison
comparison = pd.DataFrame({
    'Type d\'Option': [
        'Call EuropÃ©en',
        'Call AmÃ©ricain',
        'Call BermudÃ©en',
        'Call Asiatique',
        'Put EuropÃ©en',
        'Put AmÃ©ricain',
        'Put BermudÃ©en',
        'Put Asiatique'
    ],
    'Prix ($)': [
        european_call,
        american_call,
        bermudan_call,
        asian_call,
        european_put,
        american_put,
        bermudan_put,
        asian_put
    ],
    '% du Prix Spot': [
        european_call/current_price*100,
        american_call/current_price*100,
        bermudan_call/current_price*100,
        asian_call/current_price*100,
        european_put/current_price*100,
        american_put/current_price*100,
        bermudan_put/current_price*100,
        asian_put/current_price*100
    ]
})

print(comparison.to_string(index=False))
print()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 8: VISUALISATIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("=" * 80)
print("  GÃ‰NÃ‰RATION DES VISUALISATIONS")
print("=" * 80)
print()

# Graphique 1: Comparaison des prix par type
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))

# Calls
call_data = comparison[comparison['Type d\'Option'].str.contains('Call')]
ax1.bar(range(len(call_data)), call_data['Prix ($)'], color=['#3498db', '#e74c3c', '#f39c12', '#9b59b6'])
ax1.set_xticks(range(len(call_data)))
ax1.set_xticklabels([t.replace('Call ', '') for t in call_data['Type d\'Option']], rotation=45, ha='right')
ax1.set_ylabel('Prix ($)', fontsize=12, fontweight='bold')
ax1.set_title('Comparaison des Prix - Options CALL', fontsize=14, fontweight='bold', pad=15)
ax1.grid(True, alpha=0.3, axis='y')

# Ajout des valeurs sur les barres
for i, v in enumerate(call_data['Prix ($)']):
    ax1.text(i, v + 0.2, f'${v:.2f}', ha='center', va='bottom', fontweight='bold')

# Puts
put_data = comparison[comparison['Type d\'Option'].str.contains('Put')]
ax2.bar(range(len(put_data)), put_data['Prix ($)'], color=['#3498db', '#e74c3c', '#f39c12', '#9b59b6'])
ax2.set_xticks(range(len(put_data)))
ax2.set_xticklabels([t.replace('Put ', '') for t in put_data['Type d\'Option']], rotation=45, ha='right')
ax2.set_ylabel('Prix ($)', fontsize=12, fontweight='bold')
ax2.set_title('Comparaison des Prix - Options PUT', fontsize=14, fontweight='bold', pad=15)
ax2.grid(True, alpha=0.3, axis='y')

# Ajout des valeurs sur les barres
for i, v in enumerate(put_data['Prix ($)']):
    ax2.text(i, v + 0.2, f'${v:.2f}', ha='center', va='bottom', fontweight='bold')

plt.tight_layout()
plt.savefig('nintendo_options_comparison.png', dpi=300, bbox_inches='tight')
print("ğŸ“ˆ Graphique sauvegardÃ©: nintendo_options_comparison.png")
print()

# Graphique 2: SensibilitÃ© au prix du sous-jacent
spot_range = np.linspace(current_price * 0.7, current_price * 1.3, 50)
european_calls = [black_scholes_european(S, strike_price, time_to_maturity, risk_free_rate, volatility, 'call') for S in spot_range]
european_puts = [black_scholes_european(S, strike_price, time_to_maturity, risk_free_rate, volatility, 'put') for S in spot_range]

fig, ax = plt.subplots(figsize=(14, 8))
ax.plot(spot_range, european_calls, label='Call EuropÃ©en', linewidth=2.5, color='#27ae60')
ax.plot(spot_range, european_puts, label='Put EuropÃ©en', linewidth=2.5, color='#e74c3c')
ax.axvline(x=current_price, color='gray', linestyle='--', linewidth=1.5, alpha=0.7, label=f'Prix actuel (${current_price:.2f})')
ax.axvline(x=strike_price, color='black', linestyle='-.', linewidth=1.5, alpha=0.7, label=f'Strike (${strike_price:.2f})')
ax.set_xlabel('Prix du Sous-jacent ($)', fontsize=12, fontweight='bold')
ax.set_ylabel('Prix de l\'Option ($)', fontsize=12, fontweight='bold')
ax.set_title('SensibilitÃ© des Prix d\'Options au Prix du Sous-jacent', fontsize=14, fontweight='bold', pad=20)
ax.legend(loc='best', framealpha=0.9, fontsize=11)
ax.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('nintendo_options_sensitivity.png', dpi=300, bbox_inches='tight')
print("ğŸ“ˆ Graphique sauvegardÃ©: nintendo_options_sensitivity.png")
print()

# Graphique 3: Surface de volatilitÃ© implicite (simplifiÃ©)
volatility_range = np.linspace(volatility * 0.5, volatility * 1.5, 30)
maturity_range = np.linspace(0.25, 2.0, 30)

call_prices = np.zeros((len(volatility_range), len(maturity_range)))

for i, vol in enumerate(volatility_range):
    for j, T in enumerate(maturity_range):
        call_prices[i, j] = black_scholes_european(current_price, strike_price, T, risk_free_rate, vol, 'call')

fig, ax = plt.subplots(figsize=(14, 8))
contour = ax.contourf(maturity_range, volatility_range * 100, call_prices, levels=20, cmap='viridis')
cbar = plt.colorbar(contour, ax=ax)
cbar.set_label('Prix du Call ($)', fontsize=11, fontweight='bold')
ax.set_xlabel('MaturitÃ© (annÃ©es)', fontsize=12, fontweight='bold')
ax.set_ylabel('VolatilitÃ© (%)', fontsize=12, fontweight='bold')
ax.set_title('Surface des Prix de Call en fonction de la VolatilitÃ© et de la MaturitÃ©',
             fontsize=14, fontweight='bold', pad=20)
ax.scatter([time_to_maturity], [volatility * 100], color='red', s=200, marker='*',
           edgecolors='white', linewidths=2, label='ParamÃ¨tres actuels', zorder=5)
ax.legend(loc='upper left', framealpha=0.9)

plt.tight_layout()
plt.savefig('nintendo_options_surface.png', dpi=300, bbox_inches='tight')
print("ğŸ“ˆ Graphique sauvegardÃ©: nintendo_options_surface.png")
print()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 9: RECOMMANDATIONS STRATÃ‰GIQUES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("=" * 80)
print("  RECOMMANDATIONS STRATÃ‰GIQUES POUR LE CLIENT")
print("=" * 80)
print()

print("ğŸ¯ ANALYSE COMPARATIVE DES TYPES D'OPTIONS:")
print()

print("1ï¸âƒ£  OPTIONS EUROPÃ‰ENNES:")
print(f"   âœ… Avantages:")
print(f"      - Prix les plus bas (Call: ${european_call:.2f}, Put: ${european_put:.2f})")
print(f"      - LiquiditÃ© gÃ©nÃ©ralement meilleure sur les marchÃ©s")
print(f"      - SimplicitÃ© de pricing (Black-Scholes)")
print(f"   âŒ InconvÃ©nients:")
print(f"      - Pas de flexibilitÃ© d'exercice anticipÃ©")
print(f"      - Peut manquer des opportunitÃ©s de profit")
print()

print("2ï¸âƒ£  OPTIONS AMÃ‰RICAINES:")
print(f"   âœ… Avantages:")
print(f"      - FlexibilitÃ© maximale (exercice Ã  tout moment)")
print(f"      - ParticuliÃ¨rement intÃ©ressant pour les puts (protection)")
print(f"      - Prime d'exercice anticipÃ©: Call +${early_exercise_premium_call:.4f}, Put +${early_exercise_premium_put:.4f}")
print(f"   âŒ InconvÃ©nients:")
print(f"      - Prix plus Ã©levÃ©s (Call: ${american_call:.2f}, Put: ${american_put:.2f})")
print(f"      - Moins liquides que les europÃ©ennes")
print()

print("3ï¸âƒ£  OPTIONS BERMUDÃ‰ENNES:")
print(f"   âœ… Avantages:")
print(f"      - Bon compromis flexibilitÃ©/coÃ»t")
print(f"      - Prix intermÃ©diaires (Call: ${bermudan_call:.2f}, Put: ${bermudan_put:.2f})")
print(f"      - Convient aux stratÃ©gies trimestrielles")
print(f"   âŒ InconvÃ©nients:")
print(f"      - Moins rÃ©pandues, liquiditÃ© moindre")
print(f"      - ComplexitÃ© de pricing")
print()

print("4ï¸âƒ£  OPTIONS ASIATIQUES:")
print(f"   âœ… Avantages:")
print(f"      - Prix rÃ©duits (Call: ${asian_call:.2f}, Put: ${asian_put:.2f})")
print(f"      - Moins sensibles aux manipulations de prix")
print(f"      - Protection contre la volatilitÃ© de fin de pÃ©riode")
print(f"   âŒ InconvÃ©nients:")
print(f"      - Payoff plus faible (basÃ© sur moyenne)")
print(f"      - Moins liquides, marchÃ©s OTC principalement")
print()

print("=" * 80)
print("  RECOMMANDATIONS FINALES")
print("=" * 80)
print()

print("ğŸ’¼ STRATÃ‰GIES RECOMMANDÃ‰ES PAR PROFIL:")
print()

print("ğŸ“ˆ POUR UN INVESTISSEUR OPTIMISTE (bullish sur Nintendo):")
print("   â†’ Option recommandÃ©e: CALL EUROPÃ‰EN")
print(f"     â€¢ Prix: ${european_call:.2f}")
print(f"     â€¢ Levier maximal pour investissement minimal")
print(f"     â€¢ Perte limitÃ©e Ã  la prime payÃ©e")
print()

print("ğŸ“‰ POUR UN INVESTISSEUR PRUDENT (protection du portefeuille):")
print("   â†’ Option recommandÃ©e: PUT AMÃ‰RICAIN")
print(f"     â€¢ Prix: ${american_put:.2f}")
print(f"     â€¢ Protection maximale avec flexibilitÃ© d'exercice")
print(f"     â€¢ PossibilitÃ© d'exercice anticipÃ© si forte baisse")
print()

print("âš–ï¸  POUR UN INVESTISSEUR Ã‰QUILIBRÃ‰:")
print("   â†’ Option recommandÃ©e: CALL/PUT BERMUDÃ‰EN")
print(f"     â€¢ Prix Call: ${bermudan_call:.2f}, Put: ${bermudan_put:.2f}")
print(f"     â€¢ Bon rapport flexibilitÃ©/coÃ»t")
print(f"     â€¢ Dates d'exercice trimestrielles")
print()

print("ğŸ² POUR UN INVESTISSEUR CHERCHANT RÃ‰DUCTION DES COÃ›TS:")
print("   â†’ Option recommandÃ©e: OPTIONS ASIATIQUES")
print(f"     â€¢ Prix Call: ${asian_call:.2f}, Put: ${asian_put:.2f}")
print(f"     â€¢ Primes rÃ©duites de ~{((european_call - asian_call)/european_call)*100:.1f}% (call) et ~{((european_put - asian_put)/european_put)*100:.1f}% (put)")
print(f"     â€¢ Convient aux horizons longs termes")
print()

print("=" * 80)
print("  POINTS CLÃ‰S Ã€ RETENIR")
print("=" * 80)
print()

print("ğŸ“Œ Points importants:")
print(f"   1. Le marchÃ© valorise actuellement Nintendo avec une volatilitÃ© de {volatility*100:.2f}%")
print(f"   2. Les options amÃ©ricaines valent ~{(american_call/european_call - 1)*100:.1f}% de plus que les europÃ©ennes (calls)")
print(f"   3. Les options asiatiques offrent une rÃ©duction de coÃ»t significative")
print(f"   4. Le choix optimal dÃ©pend de:")
print(f"      - L'objectif d'investissement (spÃ©culation vs couverture)")
print(f"      - L'horizon temporel")
print(f"      - La tolÃ©rance au risque")
print(f"      - Le besoin de flexibilitÃ© d'exercice")
print()

print("âš ï¸  MISE EN GARDE:")
print("   - Ces calculs sont basÃ©s sur des modÃ¨les thÃ©oriques")
print("   - Les prix rÃ©els de marchÃ© peuvent diffÃ©rer")
print("   - ConsidÃ©rer les coÃ»ts de transaction dans la dÃ©cision finale")
print("   - Consulter un conseiller financier pour toute dÃ©cision d'investissement")
print()

print("=" * 80)
print("  FIN DE L'ANALYSE - OPTION PRICING")
print("=" * 80)
