# -*- coding: utf-8 -*-
"""Projet-final-Nintendo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DFbzRpkYmt6vzG4kHRCkDku6DtUn4Z9J
"""

# ==========================================
# Portefeuille centrÃ© Nintendo - version interactive (dÃ©butant)
# ==========================================
# - Nintendo imposÃ©e
# - Poids de Nintendo FIXE choisi par l'utilisateur
# - Affichage avec noms d'entreprises (pas les tickers)
# - Tri croissant des allocations + mÃªme ordre sur le graphe
# - Suggestion de poids Nintendo si la cible n'est pas atteinte
# - BOUCLE : on rejoue la simulation tant que l'investisseur rÃ©pond OUI
# ==========================================

from __future__ import annotations
import warnings
from dataclasses import dataclass
from typing import List

import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt

# cvxpy optionnel (QP). Fallback prÃ©vu si absent.
try:
    import cvxpy as cp
    HAS_CVXPY = True
except Exception:
    HAS_CVXPY = False

warnings.filterwarnings("ignore")

# -------------------------------------
# Config de base
# -------------------------------------
NINTENDO = "NTDOY"  # Nintendo imposÃ©e (ADR US)
DEFAULT_PEERS = ["EA", "TTWO", "SONY", "MSFT", "7832.T", "9697.T", "9684.T", "9766.T", "UBI.PA", "TCEHY"]
START, END = "2015-09-30", "2025-09-30"

TICKER_NAME = {
    "NTDOY": "Nintendo (ADR)",
    "7974.T": "Nintendo (Tokyo)",
    "EA": "Electronic Arts",
    "TTWO": "Take-Two Interactive",
    "SONY": "Sony Group (ADR)",
    "MSFT": "Microsoft",
    "7832.T": "Bandai Namco",
    "9697.T": "Capcom",
    "9684.T": "Square Enix",
    "9766.T": "Konami",
    "UBI.PA": "Ubisoft",
    "TCEHY": "Tencent (ADR)",
}

ORDER = "asc"  # tri des allocations


# -------------------------------------
# Fonctions d'entrÃ©e utilisateur
# -------------------------------------
def ask_float_pct(msg: str, default: float, lo: float = 0.0, hi: float = 1.0) -> float:
    """Demande un pourcentage lisible (6, 6%, 0.06). Renvoie un float dans [0..1]."""
    while True:
        s = input(f"{msg} [{int(default*100)}%]: ").strip().lower()
        if not s:
            return default
        try:
            s = s.replace(",", ".")
            if s.endswith("%"):
                x = float(s[:-1]) / 100
            else:
                x = float(s)
                if x > 1:
                    x = x / 100
        except ValueError:
            print("â†’ Merci d'entrer un nombre (ex: 6, 6%, 0.06).")
            continue
        if lo <= x <= hi:
            return x
        print(f"â†’ Le pourcentage doit Ãªtre entre {lo:.0%} et {hi:.0%}.")


def ask_int(msg: str, default: int, lo: int = 1, hi: int = 20) -> int:
    """Demande un entier (ex: annÃ©es)."""
    while True:
        s = input(f"{msg} [{default}]: ").strip()
        if not s:
            return default
        if s.isdigit():
            x = int(s)
            if lo <= x <= hi:
                return x
        print(f"â†’ Entrer un entier entre {lo} et {hi}.")


# -------------------------------------
# DonnÃ©es Yahoo & mÃ©triques
# -------------------------------------
def download_prices(tickers: List[str], start: str, end: str) -> pd.DataFrame:
    data = yf.download(tickers, start=start, end=end, progress=False, auto_adjust=True)
    if isinstance(data.columns, pd.MultiIndex):
        data = data["Close"]
    return data.ffill().dropna()


def pct_returns(prices: pd.DataFrame) -> pd.DataFrame:
    return prices.pct_change().dropna()


def ann_perf(r: pd.Series):
    """Retourne (rendement annuel, vol annuelle, Sharpe) sur une sÃ©rie de rendements quotidiens."""
    ann_ret = (1 + r).prod()**(252/len(r)) - 1
    ann_vol = r.std() * np.sqrt(252)
    sharpe = ann_ret / (ann_vol + 1e-12)
    return ann_ret, ann_vol, sharpe


# -------------------------------------
# Contraintes & optimisation
# -------------------------------------
@dataclass
class Constraints:
    min_center_weight: float = 0.10
    max_center_weight: float = 0.80
    max_weight_per_name: float = 0.25


cons = Constraints()


def optimize_mv(mu: pd.Series, cov: pd.DataFrame, tickers: List[str],
                center: str, cons: Constraints, target_center_weight: float) -> pd.Series:
    """Optimisation moyenne-variance avec poids FIXE sur Nintendo."""
    n = len(tickers)
    if HAS_CVXPY:
        w = cp.Variable(n)
        idx_center = tickers.index(center)

        constraints = [cp.sum(w) == 1.0, w >= 0]
        for i in range(n):
            if i != idx_center:
                constraints.append(w[i] <= cons.max_weight_per_name)
        constraints.append(w[idx_center] == target_center_weight)

        Sigma = cov.values
        Sigma = 0.5 * (Sigma + Sigma.T)
        eps = 1e-6 * np.mean(np.diag(Sigma))
        np.fill_diagonal(Sigma, np.diag(Sigma) + eps)
        gamma = 10.0 / max(np.trace(Sigma), 1e-8)

        objective = cp.Maximize(mu.values @ w - 0.5 * gamma * cp.quad_form(w, Sigma))
        prob = cp.Problem(objective, constraints)
        try:
            prob.solve(solver=cp.OSQP, verbose=False)
        except Exception:
            prob.solve(solver=cp.SCS, verbose=False)

        if w.value is None:
            raise RuntimeError("Optimisation impossible.")
        wv = np.array(w.value).ravel()
        wv = wv / wv.sum()
        return pd.Series(wv, index=tickers)
    else:
        # Fallback simple : poids Nintendo fixÃ©, reste en Ã©quipondÃ©rÃ©
        weights = pd.Series(0.0, index=tickers)
        weights[center] = target_center_weight
        others = [t for t in tickers if t != center]
        rest = 1.0 - weights.sum()
        if rest < 0:
            raise RuntimeError("Poids Nintendo trop Ã©levÃ© pour la heuristique.")
        if others:
            weights[others] = rest / len(others)
        return weights

# --------------------------------------------------------
# BOUCLE RÃ‰PÃ‰TÃ‰E : exÃ©cuter plein de simulations d'affilÃ©e
# --------------------------------------------------------

while True:

    print("""
ðŸ‘‹ Nouvelle configuration de portefeuille centrÃ©e sur Nintendo.
RÃ©ponds aux questions pour gÃ©nÃ©rer une nouvelle simulation.
""")

    # ======= QUESTIONS INVESTISSEUR =======
    target_return = ask_float_pct("Quel rendement annuel vises-tu ?", 0.06, 0.0, 0.3)
    horizon_years = ask_int("Sur combien d'annÃ©es envisages-tu d'investir ?", 3, 1, 20)
    nintendo_weight = ask_float_pct(
        "Quel pourcentage souhaites-tu allouer Ã  Nintendo ?",
        0.30,
        cons.min_center_weight,
        cons.max_center_weight,
    )

    # ======= DONNÃ‰ES =======
    print("\nTÃ©lÃ©chargement des donnÃ©es Yahoo Finance...")
    universe = [NINTENDO] + DEFAULT_PEERS
    prices = download_prices(universe, START, END)
    returns = pct_returns(prices)

    tickers = list(returns.columns)
    center = NINTENDO if NINTENDO in tickers else tickers[0]

    mu_ann = returns.mean() * 252
    cov_ann = returns.cov() * 252

    # ======= OPTIMISATION =======
    weights = optimize_mv(
        mu_ann.loc[tickers],
        cov_ann.loc[tickers, tickers],
        tickers,
        center,
        cons,
        target_center_weight=nintendo_weight
    )

    port_rets = (returns[tickers] * weights).sum(axis=1)
    ann_ret, ann_vol, sharpe = ann_perf(port_rets)

    # ======= AFFICHAGE RESULTATS =======
    print("\nðŸ§® Allocation finale avec Nintendo fixÃ© Ã ", f"{nintendo_weight:.0%}")
    alloc_df = pd.DataFrame({"w": weights})
    alloc_df["name"] = alloc_df.index.map(lambda t: TICKER_NAME.get(t, t))
    alloc_df = alloc_df.sort_values("w")
    alloc_named = alloc_df.set_index("name")["w"]
    print((alloc_named * 100).round(2).astype(str) + " %")

    print(f"\nðŸŽ¯ RÃ©sultats estimÃ©s pour cette configuration :")
    print(f"  â€¢ Rendement annuel estimÃ© : {ann_ret:.2%}")
    print(f"  â€¢ VolatilitÃ© annuelle estimÃ©e : {ann_vol:.2%}")
    print(f"  â€¢ Ratio de Sharpe : {sharpe:.2f}")
    print(f"  â€¢ Horizon d'investissement dÃ©clarÃ© : {horizon_years} ans")

    # ======= GRAPHIQUE =======
    growth_port = (1 + port_rets).cumprod()
    plt.figure(figsize=(10,5))
    (prices / prices.iloc[0]).rename(columns=lambda t: TICKER_NAME.get(t, t)).plot(alpha=0.5)
    growth_port.plot(label="Portefeuille proposÃ©", linewidth=2)
    plt.legend()
    plt.title("Ã‰volution du portefeuille (base 1.0)")
    plt.tight_layout()
    plt.show()

    print("\n" + "="*80)

    # ======= QUESTION DE RELANCE =======
    rep = input("Souhaites-tu lancer une NOUVELLE simulation avec dâ€™autres paramÃ¨tres ? [o/N]: ").strip().lower()
    if rep not in ("o", "oui", "y", "yes"):
        print("ðŸ‘‰ Fin des simulations.")
        break

    print("\n=== Nouvelle simulation ===\n")
