# -*- coding: utf-8 -*-
"""Nintendo - Option pricing - V2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18m1oxCouV-Atsthb3VZ4S8TDj-lruW0U
"""

# -*- coding: utf-8 -*-
"""
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    CONSEIL EN PRICING D'OPTIONS - NINTENDO (NTDOY)
    PÃ©riode: Septembre 2015 - Septembre 2025

    Types d'options Ã©valuÃ©s pour l'investisseur :
    1. Options EuropÃ©ennes (Black-Scholes-Merton)
    2. Options AmÃ©ricaines (Binomial Tree)
    3. Options BermudÃ©ennes (Binomial Tree modifiÃ©)
    4. Options Exotiques - Asiatiques (Monte Carlo)
    5. Greeks pour gestion du risque

    Approche personnalisÃ©e selon le profil et objectifs d'investissement
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 1: IMPORTS ET CONFIGURATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import numpy as np
import pandas as pd
import yfinance as yf
from scipy.stats import norm
from datetime import datetime, timedelta
import warnings
warnings.filterwarnings('ignore')

# BibliothÃ¨ques pour graphiques interactifs
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import plotly.express as px

print("=" * 80)
print("  CONSEIL EN PRICING D'OPTIONS - NINTENDO (NTDOY)")
print("=" * 80)
print()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 2: RÃ‰CUPÃ‰RATION DES DONNÃ‰ES NINTENDO
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("ğŸ“¥ TÃ©lÃ©chargement des donnÃ©es Nintendo...")

ticker = "NTDOY"
start_date = "2015-09-01"
end_date = "2025-09-30"

# TÃ©lÃ©chargement des donnÃ©es
nintendo_data = yf.download(ticker, start=start_date, end=end_date, progress=False)
data = nintendo_data['Close']
data.columns = ['Close']

# Prix actuel (derniÃ¨re observation)
S0 = data['Close'].iloc[-1]

# Calcul de la volatilitÃ© historique (annualisÃ©e)
returns = np.log(data['Close'] / data['Close'].shift(1))
volatility_hist = returns.std() * np.sqrt(252)

print(f"âœ… DonnÃ©es tÃ©lÃ©chargÃ©es: {len(data)} jours de trading")
print(f"   PÃ©riode: {data.index[0].strftime('%Y-%m-%d')} Ã  {data.index[-1].strftime('%Y-%m-%d')}")
print(f"   Prix actuel (S0): ${S0:.2f}")
print(f"   VolatilitÃ© historique (annualisÃ©e): {volatility_hist*100:.2f}%")
print()

# Taux sans risque (US Treasury 10Y source : https://www.cnbc.com/quotes/US10Y le 26/11/2025)
r = 0.04  # 4% par dÃ©faut, ajustable selon contexte macroÃ©conomique

print(f"   Taux sans risque utilisÃ©: {r*100:.2f}%")
print()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 3: PROFIL D'INVESTISSEUR - PERSONNALISATION AVANCÃ‰E
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("=" * 80)
print("  PERSONNALISATION SELON VOTRE PROFIL D'INVESTISSEUR")
print("=" * 80)
print()

print("ğŸ“‹ Ã‰TAPE 1: Quel est votre profil d'investisseur?")
print("   1. COUVERTURE (HEDGING) : Vous dÃ©tenez des actions Nintendo et voulez vous protÃ©ger")
print("   2. SPÃ‰CULATION HAUSSIÃˆRE : Vous anticipez une hausse du prix")
print("   3. SPÃ‰CULATION BAISSIÃˆRE : Vous anticipez une baisse du prix")
print("   4. GÃ‰NÃ‰RATION DE REVENUS : Vous voulez gÃ©nÃ©rer des revenus rÃ©guliers (stratÃ©gies covered call)")
print("   5. VOLATILITÃ‰ : Vous voulez profiter des variations de volatilitÃ©")
print()

# Configuration par dÃ©faut (peut Ãªtre modifiÃ©e)
PROFIL_INVESTISSEUR = 2  # SPÃ‰CULATION HAUSSIÃˆRE par dÃ©faut

profils_investisseur = {
    1: {
        'nom': 'COUVERTURE (HEDGING)',
        'strategie_principale': 'Achat de Puts pour protection',
        'options_recommandees': ['Put EuropÃ©en', 'Put AmÃ©ricain'],
        'horizon_typique': 'Court Ã  Moyen terme (3-6 mois)',
        'delta_target': 'NÃ©gatif (protection)',
        'description': 'Minimiser les pertes en cas de baisse du sous-jacent'
    },
    2: {
        'nom': 'SPÃ‰CULATION HAUSSIÃˆRE',
        'strategie_principale': 'Achat de Calls',
        'options_recommandees': ['Call EuropÃ©en', 'Call AmÃ©ricain', 'Call Asiatique'],
        'horizon_typique': 'Moyen terme (6-12 mois)',
        'delta_target': 'Positif Ã©levÃ© (>0.5)',
        'description': 'Profiter d\'une hausse anticipÃ©e avec effet de levier'
    },
    3: {
        'nom': 'SPÃ‰CULATION BAISSIÃˆRE',
        'strategie_principale': 'Achat de Puts',
        'options_recommandees': ['Put EuropÃ©en', 'Put AmÃ©ricain'],
        'horizon_typique': 'Court Ã  Moyen terme (3-9 mois)',
        'delta_target': 'NÃ©gatif (<-0.3)',
        'description': 'Profiter d\'une baisse anticipÃ©e'
    },
    4: {
        'nom': 'GÃ‰NÃ‰RATION DE REVENUS',
        'strategie_principale': 'Vente de Calls couverts (Covered Calls)',
        'options_recommandees': ['Call EuropÃ©en OTM', 'Call BermudÃ©en'],
        'horizon_typique': 'Court terme rÃ©pÃ©tÃ© (1-3 mois)',
        'delta_target': 'LÃ©gÃ¨rement positif (0.3-0.5)',
        'description': 'Collecter des primes en vendant des calls sur actions dÃ©tenues'
    },
    5: {
        'nom': 'VOLATILITÃ‰',
        'strategie_principale': 'Straddle/Strangle',
        'options_recommandees': ['Call & Put EuropÃ©ens', 'Options Exotiques'],
        'horizon_typique': 'Court terme (1-3 mois)',
        'delta_target': 'Neutre (proche de 0)',
        'description': 'Profiter des mouvements de prix importants sans direction prÃ©cise'
    }
}

profil = profils_investisseur[PROFIL_INVESTISSEUR]
print(f"âœ… Profil sÃ©lectionnÃ©: {profil['nom']}")
print(f"   StratÃ©gie principale: {profil['strategie_principale']}")
print(f"   Options recommandÃ©es: {', '.join(profil['options_recommandees'])}")
print(f"   Horizon typique: {profil['horizon_typique']}")
print(f"   Description: {profil['description']}")
print()

print("ğŸ“‹ Ã‰TAPE 2: DÃ©finition des paramÃ¨tres personnalisÃ©s")
print()

# ParamÃ¨tres ajustables selon le profil
if PROFIL_INVESTISSEUR == 1:  # COUVERTURE
    strikes_range = [0.90, 0.95, 1.00]  # OTM, ATM
    maturities_months = [3, 6, 9]
    option_types_focus = ['put']

elif PROFIL_INVESTISSEUR == 2:  # HAUSSIER
    strikes_range = [0.95, 1.00, 1.05, 1.10]  # ATM, lÃ©gÃ¨rement OTM
    maturities_months = [6, 9, 12]
    option_types_focus = ['call']

elif PROFIL_INVESTISSEUR == 3:  # BAISSIER
    strikes_range = [0.90, 0.95, 1.00, 1.05]
    maturities_months = [3, 6, 9]
    option_types_focus = ['put']

elif PROFIL_INVESTISSEUR == 4:  # REVENUS
    strikes_range = [1.00, 1.05, 1.10]  # ATM et OTM (pour vente)
    maturities_months = [1, 2, 3]
    option_types_focus = ['call']

else:  # VOLATILITÃ‰
    strikes_range = [0.95, 1.00, 1.05]
    maturities_months = [1, 2, 3]
    option_types_focus = ['call', 'put']

# GÃ©nÃ©ration des strikes et maturitÃ©s
K_multipliers = strikes_range
K_values = [S0 * mult for mult in K_multipliers]
T_values = [m/12 for m in maturities_months]

print(f"   Prix sous-jacent (S0): ${S0:.2f}")
print(f"   Strikes Ã©valuÃ©s: {[f'${k:.2f}' for k in K_values]}")
print(f"   MaturitÃ©s Ã©valuÃ©es: {maturities_months} mois")
print(f"   VolatilitÃ© utilisÃ©e: {volatility_hist*100:.2f}% (historique)")
print(f"   Taux sans risque: {r*100:.2f}%")
print()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 4: MODÃˆLES DE PRICING - FONCTIONS PRINCIPALES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("=" * 80)
print("  MODÃˆLES DE PRICING D'OPTIONS")
print("=" * 80)
print()

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 4.1: Black-Scholes-Merton (Options EuropÃ©ennes)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def black_scholes_call(S, K, T, r, sigma):
    """Prix d'un call europÃ©en selon Black-Scholes-Merton"""
    if T <= 0:
        return max(S - K, 0)
    d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    call_price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)
    return call_price

def black_scholes_put(S, K, T, r, sigma):
    """Prix d'un put europÃ©en selon Black-Scholes-Merton"""
    if T <= 0:
        return max(K - S, 0)
    d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    put_price = K * np.exp(-r * T) * norm.cdf(-d2) - S * norm.cdf(-d1)
    return put_price

# Greeks pour Black-Scholes
def bs_greeks(S, K, T, r, sigma, option_type='call'):
    """Calcul des Greeks (Delta, Gamma, Vega, Theta, Rho)"""
    if T <= 0:
        return {'delta': 0, 'gamma': 0, 'vega': 0, 'theta': 0, 'rho': 0}

    d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)

    if option_type == 'call':
        delta = norm.cdf(d1)
        theta = (-(S * norm.pdf(d1) * sigma) / (2 * np.sqrt(T))
                 - r * K * np.exp(-r * T) * norm.cdf(d2)) / 365
        rho = K * T * np.exp(-r * T) * norm.cdf(d2) / 100
    else:  # put
        delta = -norm.cdf(-d1)
        theta = (-(S * norm.pdf(d1) * sigma) / (2 * np.sqrt(T))
                 + r * K * np.exp(-r * T) * norm.cdf(-d2)) / 365
        rho = -K * T * np.exp(-r * T) * norm.cdf(-d2) / 100

    gamma = norm.pdf(d1) / (S * sigma * np.sqrt(T))
    vega = S * norm.pdf(d1) * np.sqrt(T) / 100

    return {
        'delta': delta,
        'gamma': gamma,
        'vega': vega,
        'theta': theta,
        'rho': rho
    }

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 4.2: Binomial Tree (Options AmÃ©ricaines et BermudÃ©ennes)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def binomial_tree_american(S, K, T, r, sigma, N, option_type='call'):
    """
    Prix d'une option amÃ©ricaine par arbre binomial
    N: nombre de pÃ©riodes
    """
    dt = T / N
    u = np.exp(sigma * np.sqrt(dt))
    d = 1 / u
    p = (np.exp(r * dt) - d) / (u - d)

    # Initialisation de l'arbre des prix
    stock_tree = np.zeros((N + 1, N + 1))
    option_tree = np.zeros((N + 1, N + 1))

    # Prix du sous-jacent Ã  maturitÃ©
    for i in range(N + 1):
        stock_tree[i, N] = S * (u ** (N - i)) * (d ** i)

    # Valeur intrinsÃ¨que Ã  maturitÃ©
    for i in range(N + 1):
        if option_type == 'call':
            option_tree[i, N] = max(stock_tree[i, N] - K, 0)
        else:
            option_tree[i, N] = max(K - stock_tree[i, N], 0)

    # Backward induction
    for j in range(N - 1, -1, -1):
        for i in range(j + 1):
            stock_tree[i, j] = S * (u ** (j - i)) * (d ** i)

            # Valeur de continuation (discounted expected value)
            continuation = np.exp(-r * dt) * (p * option_tree[i, j + 1] +
                                               (1 - p) * option_tree[i + 1, j + 1])

            # Valeur d'exercice immÃ©diat
            if option_type == 'call':
                exercise = max(stock_tree[i, j] - K, 0)
            else:
                exercise = max(K - stock_tree[i, j], 0)

            # Pour une option amÃ©ricaine: max(continuation, exercise)
            option_tree[i, j] = max(continuation, exercise)

    return option_tree[0, 0]

def binomial_tree_bermudan(S, K, T, r, sigma, N, exercise_dates, option_type='call'):
    """
    Prix d'une option bermudÃ©enne par arbre binomial
    exercise_dates: liste des indices de pÃ©riodes oÃ¹ l'exercice est permis
    """
    dt = T / N
    u = np.exp(sigma * np.sqrt(dt))
    d = 1 / u
    p = (np.exp(r * dt) - d) / (u - d)

    stock_tree = np.zeros((N + 1, N + 1))
    option_tree = np.zeros((N + 1, N + 1))

    # Prix du sous-jacent Ã  maturitÃ©
    for i in range(N + 1):
        stock_tree[i, N] = S * (u ** (N - i)) * (d ** i)

    # Valeur intrinsÃ¨que Ã  maturitÃ©
    for i in range(N + 1):
        if option_type == 'call':
            option_tree[i, N] = max(stock_tree[i, N] - K, 0)
        else:
            option_tree[i, N] = max(K - stock_tree[i, N], 0)

    # Backward induction
    for j in range(N - 1, -1, -1):
        for i in range(j + 1):
            stock_tree[i, j] = S * (u ** (j - i)) * (d ** i)

            continuation = np.exp(-r * dt) * (p * option_tree[i, j + 1] +
                                               (1 - p) * option_tree[i + 1, j + 1])

            if option_type == 'call':
                exercise = max(stock_tree[i, j] - K, 0)
            else:
                exercise = max(K - stock_tree[i, j], 0)

            # Exercice possible seulement aux dates bermudÃ©ennes
            if j in exercise_dates:
                option_tree[i, j] = max(continuation, exercise)
            else:
                option_tree[i, j] = continuation

    return option_tree[0, 0]

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 4.3: Monte Carlo (Options Asiatiques)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def asian_option_monte_carlo(S, K, T, r, sigma, n_simulations=50000, n_steps=252, option_type='call'):
    """
    Prix d'une option asiatique (moyenne arithmÃ©tique) par Monte Carlo
    """
    dt = T / n_steps
    discount_factor = np.exp(-r * T)

    payoffs = []

    for _ in range(n_simulations):
        # Simulation du chemin du prix
        prices = [S]
        for _ in range(n_steps):
            z = np.random.standard_normal()
            S_next = prices[-1] * np.exp((r - 0.5 * sigma**2) * dt + sigma * np.sqrt(dt) * z)
            prices.append(S_next)

        # Prix moyen
        avg_price = np.mean(prices)

        # Payoff
        if option_type == 'call':
            payoff = max(avg_price - K, 0)
        else:
            payoff = max(K - avg_price, 0)

        payoffs.append(payoff)

    # Prix de l'option
    option_price = discount_factor * np.mean(payoffs)
    std_error = discount_factor * np.std(payoffs) / np.sqrt(n_simulations)

    return option_price, std_error

print("âœ… ModÃ¨les de pricing implÃ©mentÃ©s:")
print("   - Black-Scholes-Merton (Options EuropÃ©ennes)")
print("   - Arbre Binomial (Options AmÃ©ricaines)")
print("   - Arbre Binomial modifiÃ© (Options BermudÃ©ennes)")
print("   - Monte Carlo (Options Asiatiques)")
print("   - Greeks (Delta, Gamma, Vega, Theta, Rho)")
print()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 5: Ã‰VALUATION DES OPTIONS SELON LE PROFIL
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("=" * 80)
print(f"  Ã‰VALUATION DES OPTIONS - PROFIL {profil['nom']}")
print("=" * 80)
print()

# Dataframe pour stocker tous les rÃ©sultats
results_all = []

for K in K_values:
    for T in T_values:
        T_months = int(T * 12)
        moneyness = S0 / K

        # DÃ©terminer si ITM, ATM, OTM
        if moneyness > 1.05:
            status = 'ITM'
        elif moneyness > 0.95:
            status = 'ATM'
        else:
            status = 'OTM'

        result = {
            'Strike': K,
            'MaturitÃ© (mois)': T_months,
            'MaturitÃ© (annÃ©es)': T,
            'Moneyness': moneyness,
            'Status': status
        }

        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # Ã‰valuation selon les types d'options recommandÃ©s
        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        if 'call' in option_types_focus:
            # Call EuropÃ©en
            call_euro = black_scholes_call(S0, K, T, r, volatility_hist)
            result['Call EuropÃ©en'] = call_euro

            # Call AmÃ©ricain
            call_american = binomial_tree_american(S0, K, T, r, volatility_hist, N=100, option_type='call')
            result['Call AmÃ©ricain'] = call_american

            # Call BermudÃ©en (exercice possible tous les 3 mois)
            n_steps = 100
            exercise_frequency = max(1, int(n_steps * 3 / (T * 12)))
            exercise_dates_berm = list(range(0, n_steps + 1, exercise_frequency))
            call_bermudan = binomial_tree_bermudan(S0, K, T, r, volatility_hist, N=n_steps,
                                                   exercise_dates=exercise_dates_berm, option_type='call')
            result['Call BermudÃ©en'] = call_bermudan

            # Call Asiatique
            call_asian, call_asian_se = asian_option_monte_carlo(S0, K, T, r, volatility_hist,
                                                                   n_simulations=30000, option_type='call')
            result['Call Asiatique'] = call_asian

            # Greeks pour Call EuropÃ©en
            greeks_call = bs_greeks(S0, K, T, r, volatility_hist, 'call')
            result['Call Delta'] = greeks_call['delta']
            result['Call Gamma'] = greeks_call['gamma']
            result['Call Vega'] = greeks_call['vega']
            result['Call Theta'] = greeks_call['theta']

        if 'put' in option_types_focus:
            # Put EuropÃ©en
            put_euro = black_scholes_put(S0, K, T, r, volatility_hist)
            result['Put EuropÃ©en'] = put_euro

            # Put AmÃ©ricain
            put_american = binomial_tree_american(S0, K, T, r, volatility_hist, N=100, option_type='put')
            result['Put AmÃ©ricain'] = put_american

            # Put BermudÃ©en
            n_steps = 100
            exercise_frequency = max(1, int(n_steps * 3 / (T * 12)))
            exercise_dates_berm = list(range(0, n_steps + 1, exercise_frequency))
            put_bermudan = binomial_tree_bermudan(S0, K, T, r, volatility_hist, N=n_steps,
                                                  exercise_dates=exercise_dates_berm, option_type='put')
            result['Put BermudÃ©en'] = put_bermudan

            # Put Asiatique
            put_asian, put_asian_se = asian_option_monte_carlo(S0, K, T, r, volatility_hist,
                                                                 n_simulations=30000, option_type='put')
            result['Put Asiatique'] = put_asian

            # Greeks pour Put EuropÃ©en
            greeks_put = bs_greeks(S0, K, T, r, volatility_hist, 'put')
            result['Put Delta'] = greeks_put['delta']
            result['Put Gamma'] = greeks_put['gamma']
            result['Put Vega'] = greeks_put['vega']
            result['Put Theta'] = greeks_put['theta']

        results_all.append(result)

# Conversion en DataFrame
df_results = pd.DataFrame(results_all)

print(f"âœ… {len(df_results)} configurations d'options Ã©valuÃ©es")
print()
print("ğŸ“Š APERÃ‡U DES RÃ‰SULTATS (premiÃ¨res lignes):")
print("-" * 80)
pd.set_option('display.max_columns', None)
pd.set_option('display.width', 120)
print(df_results.head(10).to_string(index=False))
print()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 6: VISUALISATIONS INTERACTIVES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("=" * 80)
print("  VISUALISATIONS INTERACTIVES")
print("=" * 80)
print()

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 6.1: Prix des options selon Strike et MaturitÃ©
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

if 'call' in option_types_focus:
    # Surface 3D pour Calls EuropÃ©ens
    strikes_unique = sorted(df_results['Strike'].unique())
    maturities_unique = sorted(df_results['MaturitÃ© (annÃ©es)'].unique())

    Z_call = []
    for T in maturities_unique:
        row = []
        for K in strikes_unique:
            val = df_results[(df_results['Strike'] == K) &
                            (df_results['MaturitÃ© (annÃ©es)'] == T)]['Call EuropÃ©en'].values
            row.append(val[0] if len(val) > 0 else 0)
        Z_call.append(row)

    fig_3d_call = go.Figure(data=[go.Surface(
        x=strikes_unique,
        y=maturities_unique,
        z=Z_call,
        colorscale='Viridis',
        colorbar=dict(title="Prix Call")
    )])

    fig_3d_call.update_layout(
        title=f'Prix Call EuropÃ©en - Surface 3D<br>Profil {profil["nom"]}',
        scene=dict(
            xaxis_title='Strike ($)',
            yaxis_title='MaturitÃ© (annÃ©es)',
            zaxis_title='Prix de l\'option ($)'
        ),
        height=700
    )

    fig_3d_call.show()
    print("ğŸ“Š Graphique interactif: Surface 3D Call EuropÃ©en gÃ©nÃ©rÃ©e")

if 'put' in option_types_focus:
    # Surface 3D pour Puts EuropÃ©ens
    Z_put = []
    for T in maturities_unique:
        row = []
        for K in strikes_unique:
            val = df_results[(df_results['Strike'] == K) &
                            (df_results['MaturitÃ© (annÃ©es)'] == T)]['Put EuropÃ©en'].values
            row.append(val[0] if len(val) > 0 else 0)
        Z_put.append(row)

    fig_3d_put = go.Figure(data=[go.Surface(
        x=strikes_unique,
        y=maturities_unique,
        z=Z_put,
        colorscale='Reds',
        colorbar=dict(title="Prix Put")
    )])

    fig_3d_put.update_layout(
        title=f'Prix Put EuropÃ©en - Surface 3D<br>Profil {profil["nom"]}',
        scene=dict(
            xaxis_title='Strike ($)',
            yaxis_title='MaturitÃ© (annÃ©es)',
            zaxis_title='Prix de l\'option ($)'
        ),
        height=700
    )

    fig_3d_put.show()
    print("ğŸ“Š Graphique interactif: Surface 3D Put EuropÃ©en gÃ©nÃ©rÃ©e")

print()

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 6.2: Comparaison des types d'options (EuropÃ©enne vs AmÃ©ricaine vs BermudÃ©enne)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

if 'call' in option_types_focus:
    # Filtrer pour une maturitÃ© spÃ©cifique (6 mois ou la plus proche)
    target_maturity = 6
    closest_maturity = min(maturities_months, key=lambda x: abs(x - target_maturity))
    df_comp = df_results[df_results['MaturitÃ© (mois)'] == closest_maturity].copy()

    fig_comp_call = go.Figure()

    fig_comp_call.add_trace(go.Scatter(
        x=df_comp['Strike'],
        y=df_comp['Call EuropÃ©en'],
        name='Call EuropÃ©en',
        mode='lines+markers',
        line=dict(color='blue', width=3)
    ))

    fig_comp_call.add_trace(go.Scatter(
        x=df_comp['Strike'],
        y=df_comp['Call AmÃ©ricain'],
        name='Call AmÃ©ricain',
        mode='lines+markers',
        line=dict(color='green', width=3)
    ))

    fig_comp_call.add_trace(go.Scatter(
        x=df_comp['Strike'],
        y=df_comp['Call BermudÃ©en'],
        name='Call BermudÃ©en',
        mode='lines+markers',
        line=dict(color='orange', width=3)
    ))

    fig_comp_call.add_trace(go.Scatter(
        x=df_comp['Strike'],
        y=df_comp['Call Asiatique'],
        name='Call Asiatique',
        mode='lines+markers',
        line=dict(color='purple', width=3, dash='dash')
    ))

    fig_comp_call.add_vline(x=S0, line_dash="dash", line_color="red",
                           annotation_text=f"Prix actuel: ${S0:.2f}")

    fig_comp_call.update_layout(
        title=f'Comparaison des Calls (MaturitÃ©: {closest_maturity} mois)<br>Profil {profil["nom"]}',
        xaxis_title='Strike ($)',
        yaxis_title='Prix de l\'option ($)',
        hovermode='x unified',
        height=600
    )

    fig_comp_call.show()
    print(f"ğŸ“Š Graphique interactif: Comparaison Calls ({closest_maturity} mois) gÃ©nÃ©rÃ©e")

if 'put' in option_types_focus:
    fig_comp_put = go.Figure()

    fig_comp_put.add_trace(go.Scatter(
        x=df_comp['Strike'],
        y=df_comp['Put EuropÃ©en'],
        name='Put EuropÃ©en',
        mode='lines+markers',
        line=dict(color='blue', width=3)
    ))

    fig_comp_put.add_trace(go.Scatter(
        x=df_comp['Strike'],
        y=df_comp['Put AmÃ©ricain'],
        name='Put AmÃ©ricain',
        mode='lines+markers',
        line=dict(color='green', width=3)
    ))

    fig_comp_put.add_trace(go.Scatter(
        x=df_comp['Strike'],
        y=df_comp['Put BermudÃ©en'],
        name='Put BermudÃ©en',
        mode='lines+markers',
        line=dict(color='orange', width=3)
    ))

    fig_comp_put.add_trace(go.Scatter(
        x=df_comp['Strike'],
        y=df_comp['Put Asiatique'],
        name='Put Asiatique',
        mode='lines+markers',
        line=dict(color='purple', width=3, dash='dash')
    ))

    fig_comp_put.add_vline(x=S0, line_dash="dash", line_color="red",
                          annotation_text=f"Prix actuel: ${S0:.2f}")

    fig_comp_put.update_layout(
        title=f'Comparaison des Puts (MaturitÃ©: {closest_maturity} mois)<br>Profil {profil["nom"]}',
        xaxis_title='Strike ($)',
        yaxis_title='Prix de l\'option ($)',
        hovermode='x unified',
        height=600
    )

    fig_comp_put.show()
    print(f"ğŸ“Š Graphique interactif: Comparaison Puts ({closest_maturity} mois) gÃ©nÃ©rÃ©e")

print()

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 6.3: Greeks (SensibilitÃ©s)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

if 'call' in option_types_focus and 'Call Delta' in df_comp.columns:
    # Greeks pour Calls
    fig_greeks_call = make_subplots(
        rows=2, cols=2,
        subplot_titles=('Delta (SensibilitÃ© au prix)', 'Gamma (SensibilitÃ© du Delta)',
                       'Vega (SensibilitÃ© Ã  la volatilitÃ©)', 'Theta (DÃ©croissance temporelle)'),
        vertical_spacing=0.12,
        horizontal_spacing=0.1
    )

    # Delta
    fig_greeks_call.add_trace(
        go.Scatter(x=df_comp['Strike'], y=df_comp['Call Delta'],
                  name='Delta', mode='lines+markers', line=dict(color='blue', width=3)),
        row=1, col=1
    )
    fig_greeks_call.add_hline(y=0.5, line_dash="dash", line_color="gray", row=1, col=1)

    # Gamma
    fig_greeks_call.add_trace(
        go.Scatter(x=df_comp['Strike'], y=df_comp['Call Gamma'],
                  name='Gamma', mode='lines+markers', line=dict(color='green', width=3)),
        row=1, col=2
    )

    # Vega
    fig_greeks_call.add_trace(
        go.Scatter(x=df_comp['Strike'], y=df_comp['Call Vega'],
                  name='Vega', mode='lines+markers', line=dict(color='orange', width=3)),
        row=2, col=1
    )

    # Theta
    fig_greeks_call.add_trace(
        go.Scatter(x=df_comp['Strike'], y=df_comp['Call Theta'],
                  name='Theta', mode='lines+markers', line=dict(color='red', width=3)),
        row=2, col=2
    )

    # Ligne verticale pour prix actuel sur tous les subplots
    for row in [1, 2]:
        for col in [1, 2]:
            fig_greeks_call.add_vline(x=S0, line_dash="dash", line_color="gray",
                                     row=row, col=col)

    fig_greeks_call.update_xaxes(title_text="Strike ($)", row=2, col=1)
    fig_greeks_call.update_xaxes(title_text="Strike ($)", row=2, col=2)

    fig_greeks_call.update_layout(
        title_text=f"Greeks des Calls EuropÃ©ens (MaturitÃ©: {closest_maturity} mois)<br>Profil {profil['nom']}",
        height=800,
        showlegend=False
    )

    fig_greeks_call.show()
    print("ğŸ“Š Graphique interactif: Greeks Calls gÃ©nÃ©rÃ©s")

if 'put' in option_types_focus and 'Put Delta' in df_comp.columns:
    # Greeks pour Puts
    fig_greeks_put = make_subplots(
        rows=2, cols=2,
        subplot_titles=('Delta (SensibilitÃ© au prix)', 'Gamma (SensibilitÃ© du Delta)',
                       'Vega (SensibilitÃ© Ã  la volatilitÃ©)', 'Theta (DÃ©croissance temporelle)'),
        vertical_spacing=0.12,
        horizontal_spacing=0.1
    )

    fig_greeks_put.add_trace(
        go.Scatter(x=df_comp['Strike'], y=df_comp['Put Delta'],
                  name='Delta', mode='lines+markers', line=dict(color='blue', width=3)),
        row=1, col=1
    )
    fig_greeks_put.add_hline(y=-0.5, line_dash="dash", line_color="gray", row=1, col=1)

    fig_greeks_put.add_trace(
        go.Scatter(x=df_comp['Strike'], y=df_comp['Put Gamma'],
                  name='Gamma', mode='lines+markers', line=dict(color='green', width=3)),
        row=1, col=2
    )

    fig_greeks_put.add_trace(
        go.Scatter(x=df_comp['Strike'], y=df_comp['Put Vega'],
                  name='Vega', mode='lines+markers', line=dict(color='orange', width=3)),
        row=2, col=1
    )

    fig_greeks_put.add_trace(
        go.Scatter(x=df_comp['Strike'], y=df_comp['Put Theta'],
                  name='Theta', mode='lines+markers', line=dict(color='red', width=3)),
        row=2, col=2
    )

    for row in [1, 2]:
        for col in [1, 2]:
            fig_greeks_put.add_vline(x=S0, line_dash="dash", line_color="gray",
                                    row=row, col=col)

    fig_greeks_put.update_xaxes(title_text="Strike ($)", row=2, col=1)
    fig_greeks_put.update_xaxes(title_text="Strike ($)", row=2, col=2)

    fig_greeks_put.update_layout(
        title_text=f"Greeks des Puts EuropÃ©ens (MaturitÃ©: {closest_maturity} mois)<br>Profil {profil['nom']}",
        height=800,
        showlegend=False
    )

    fig_greeks_put.show()
    print("ğŸ“Š Graphique interactif: Greeks Puts gÃ©nÃ©rÃ©s")

print()

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 6.4: Heatmap Moneyness vs MaturitÃ©
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

if 'call' in option_types_focus:
    # Pivot pour heatmap
    pivot_call = df_results.pivot_table(
        values='Call EuropÃ©en',
        index='Strike',
        columns='MaturitÃ© (mois)',
        aggfunc='mean'
    )

    fig_heatmap_call = go.Figure(data=go.Heatmap(
        z=pivot_call.values,
        x=pivot_call.columns,
        y=pivot_call.index,
        colorscale='Viridis',
        colorbar=dict(title="Prix Call ($)")
    ))

    fig_heatmap_call.update_layout(
        title=f'Heatmap: Prix Call EuropÃ©en selon Strike et MaturitÃ©<br>Profil {profil["nom"]}',
        xaxis_title='MaturitÃ© (mois)',
        yaxis_title='Strike ($)',
        height=600
    )

    fig_heatmap_call.show()
    print("ğŸ“Š Graphique interactif: Heatmap Call gÃ©nÃ©rÃ©e")

if 'put' in option_types_focus:
    pivot_put = df_results.pivot_table(
        values='Put EuropÃ©en',
        index='Strike',
        columns='MaturitÃ© (mois)',
        aggfunc='mean'
    )

    fig_heatmap_put = go.Figure(data=go.Heatmap(
        z=pivot_put.values,
        x=pivot_put.columns,
        y=pivot_put.index,
        colorscale='Reds',
        colorbar=dict(title="Prix Put ($)")
    ))

    fig_heatmap_put.update_layout(
        title=f'Heatmap: Prix Put EuropÃ©en selon Strike et MaturitÃ©<br>Profil {profil["nom"]}',
        xaxis_title='MaturitÃ© (mois)',
        yaxis_title='Strike ($)',
        height=600
    )

    fig_heatmap_put.show()
    print("ğŸ“Š Graphique interactif: Heatmap Put gÃ©nÃ©rÃ©e")

print()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 7: ANALYSE COMPARATIVE ET RECOMMANDATIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("=" * 80)
print("  ANALYSE COMPARATIVE - OPTIONS EUROPÃ‰ENNES VS AMÃ‰RICAINES")
print("=" * 80)
print()

if 'call' in option_types_focus:
    # Calcul de la prime amÃ©ricaine (diffÃ©rence entre amÃ©ricaine et europÃ©enne)
    df_results['Prime AmÃ©ricaine Call'] = df_results['Call AmÃ©ricain'] - df_results['Call EuropÃ©en']

    print("ğŸ“Š ANALYSE DES CALLS:")
    print("-" * 80)
    print(f"{'Strike':<15} {'MaturitÃ©':<15} {'Euro':<15} {'AmÃ©ricain':<15} {'Prime Am.':<15} {'Recommandation':<20}")
    print("-" * 80)

    for _, row in df_results.head(10).iterrows():
        strike = f"${row['Strike']:.2f}"
        maturity = f"{int(row['MaturitÃ© (mois)'])} mois"
        euro = f"${row['Call EuropÃ©en']:.2f}"
        american = f"${row['Call AmÃ©ricain']:.2f}"
        prime = f"${row['Prime AmÃ©ricaine Call']:.4f}"

        # Recommandation basÃ©e sur la prime
        if row['Prime AmÃ©ricaine Call'] > 0.50:
            rec = "AmÃ©ricain prÃ©fÃ©rable"
        elif row['Prime AmÃ©ricaine Call'] > 0.10:
            rec = "AmÃ©ricain lÃ©gÃ¨rement +"
        else:
            rec = "EuropÃ©en suffisant"

        print(f"{strike:<15} {maturity:<15} {euro:<15} {american:<15} {prime:<15} {rec:<20}")

    print()

    # Statistiques agrÃ©gÃ©es
    avg_prime_call = df_results['Prime AmÃ©ricaine Call'].mean()
    print(f"ğŸ’¡ Prime amÃ©ricaine moyenne pour Calls: ${avg_prime_call:.4f}")
    print(f"   â†’ L'exercice anticipÃ© {'vaut' if avg_prime_call > 0.20 else 'ne vaut pas vraiment'} le surcoÃ»t")
    print()

if 'put' in option_types_focus:
    df_results['Prime AmÃ©ricaine Put'] = df_results['Put AmÃ©ricain'] - df_results['Put EuropÃ©en']

    print("ğŸ“Š ANALYSE DES PUTS:")
    print("-" * 80)
    print(f"{'Strike':<15} {'MaturitÃ©':<15} {'Euro':<15} {'AmÃ©ricain':<15} {'Prime Am.':<15} {'Recommandation':<20}")
    print("-" * 80)

    for _, row in df_results.head(10).iterrows():
        strike = f"${row['Strike']:.2f}"
        maturity = f"{int(row['MaturitÃ© (mois)'])} mois"
        euro = f"${row['Put EuropÃ©en']:.2f}"
        american = f"${row['Put AmÃ©ricain']:.2f}"
        prime = f"${row['Prime AmÃ©ricaine Put']:.4f}"

        if row['Prime AmÃ©ricaine Put'] > 0.50:
            rec = "AmÃ©ricain prÃ©fÃ©rable"
        elif row['Prime AmÃ©ricaine Put'] > 0.10:
            rec = "AmÃ©ricain lÃ©gÃ¨rement +"
        else:
            rec = "EuropÃ©en suffisant"

        print(f"{strike:<15} {maturity:<15} {euro:<15} {american:<15} {prime:<15} {rec:<20}")

    print()

    avg_prime_put = df_results['Prime AmÃ©ricaine Put'].mean()
    print(f"ğŸ’¡ Prime amÃ©ricaine moyenne pour Puts: ${avg_prime_put:.4f}")
    print(f"   â†’ L'exercice anticipÃ© {'vaut' if avg_prime_put > 0.20 else 'ne vaut pas vraiment'} le surcoÃ»t")
    print()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 8: RECOMMANDATIONS PERSONNALISÃ‰ES POUR L'INVESTISSEUR
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("=" * 80)
print(f"  RECOMMANDATIONS POUR PROFIL: {profil['nom']}")
print("=" * 80)
print()

# Identification des meilleures options selon le profil
if PROFIL_INVESTISSEUR == 1:  # COUVERTURE
    print("ğŸ¯ STRATÃ‰GIE DE COUVERTURE (HEDGING):")
    print()
    print("   Vous dÃ©tenez des actions Nintendo et voulez vous protÃ©ger contre une baisse.")
    print()

    # Meilleur Put pour protection
    best_hedge = df_results[df_results['Status'] == 'ATM'].nsmallest(3, 'MaturitÃ© (mois)')

    print("   ğŸ“‹ OPTIONS RECOMMANDÃ‰ES (Protective Puts):")
    for i, (idx, row) in enumerate(best_hedge.iterrows(), 1):
        print(f"   {i}. Put AmÃ©ricain")
        print(f"      - Strike: ${row['Strike']:.2f} ({row['Status']})")
        print(f"      - MaturitÃ©: {int(row['MaturitÃ© (mois)'])} mois")
        print(f"      - Prix: ${row['Put AmÃ©ricain']:.2f}")
        print(f"      - Delta: {row['Put Delta']:.3f} (Couverture de {abs(row['Put Delta'])*100:.1f}%)")
        print(f"      - CoÃ»t pour 100 actions: ${row['Put AmÃ©ricain']*100:.2f}")
        print()

    print("   ğŸ’¡ CONSEIL:")
    print("      - Acheter 1 put par 100 actions dÃ©tenues")
    print("      - PrivilÃ©gier un strike ATM ou lÃ©gÃ¨rement OTM pour rÃ©duire le coÃ»t")
    print("      - Renouveler tous les 3-6 mois (rolling hedge)")
    print()

elif PROFIL_INVESTISSEUR == 2:  # HAUSSIER
    print("ğŸ¯ STRATÃ‰GIE SPÃ‰CULATIVE HAUSSIÃˆRE:")
    print()
    print("   Vous anticipez une hausse du prix de Nintendo et voulez profiter de l'effet de levier.")
    print()

    # Meilleurs Calls pour spÃ©culation
    best_calls = df_results[df_results['Status'].isin(['ATM', 'OTM'])].nsmallest(5, 'Call EuropÃ©en')

    print("   ğŸ“‹ OPTIONS RECOMMANDÃ‰ES (Long Calls):")
    for i, (idx, row) in enumerate(best_calls.iterrows(), 1):
        leverage = S0 / row['Call EuropÃ©en'] if row['Call EuropÃ©en'] > 0 else 0
        breakeven = row['Strike'] + row['Call EuropÃ©en']
        required_move = ((breakeven / S0) - 1) * 100

        print(f"   {i}. Call EuropÃ©en")
        print(f"      - Strike: ${row['Strike']:.2f} ({row['Status']})")
        print(f"      - MaturitÃ©: {int(row['MaturitÃ© (mois)'])} mois")
        print(f"      - Prix: ${row['Call EuropÃ©en']:.2f}")
        print(f"      - Delta: {row['Call Delta']:.3f}")
        print(f"      - Effet de levier: {leverage:.1f}x")
        print(f"      - Point mort: ${breakeven:.2f} (hausse de {required_move:.1f}% nÃ©cessaire)")
        print()

    print("   ğŸ’¡ CONSEIL:")
    print("      - PrivilÃ©gier des calls ATM ou lÃ©gÃ¨rement OTM pour bon Ã©quilibre coÃ»t/levier")
    print("      - MaturitÃ© 6-12 mois pour laisser le temps Ã  la hausse de se matÃ©rialiser")
    print(f"      - Risque limitÃ© Ã  la prime payÃ©e (max ${best_calls.iloc[0]['Call EuropÃ©en']:.2f} par option)")
    print("      - Potentiel de gain illimitÃ©")
    print()

elif PROFIL_INVESTISSEUR == 3:  # BAISSIER
    print("ğŸ¯ STRATÃ‰GIE SPÃ‰CULATIVE BAISSIÃˆRE:")
    print()
    print("   Vous anticipez une baisse du prix de Nintendo.")
    print()

    best_puts = df_results[df_results['Status'].isin(['ATM', 'OTM'])].nsmallest(5, 'Put EuropÃ©en')

    print("   ğŸ“‹ OPTIONS RECOMMANDÃ‰ES (Long Puts):")
    for i, (idx, row) in enumerate(best_puts.iterrows(), 1):
        leverage = S0 / row['Put EuropÃ©en'] if row['Put EuropÃ©en'] > 0 else 0
        breakeven = row['Strike'] - row['Put EuropÃ©en']
        required_move = ((S0 / breakeven) - 1) * 100

        print(f"   {i}. Put EuropÃ©en")
        print(f"      - Strike: ${row['Strike']:.2f} ({row['Status']})")
        print(f"      - MaturitÃ©: {int(row['MaturitÃ© (mois)'])} mois")
        print(f"      - Prix: ${row['Put EuropÃ©en']:.2f}")
        print(f"      - Delta: {row['Put Delta']:.3f}")
        print(f"      - Effet de levier: {leverage:.1f}x")
        print(f"      - Point mort: ${breakeven:.2f} (baisse de {required_move:.1f}% nÃ©cessaire)")
        print()

    print("   ğŸ’¡ CONSEIL:")
    print("      - Puts ATM offrent bon Ã©quilibre sensibilitÃ©/coÃ»t")
    print("      - MaturitÃ© 3-6 mois suffisante pour mouvements baissiers")
    print(f"      - Risque limitÃ© Ã  la prime (max ${best_puts.iloc[0]['Put EuropÃ©en']:.2f})")
    print()

elif PROFIL_INVESTISSEUR == 4:  # REVENUS
    print("ğŸ¯ STRATÃ‰GIE DE GÃ‰NÃ‰RATION DE REVENUS (COVERED CALLS):")
    print()
    print("   Vous dÃ©tenez des actions Nintendo et voulez gÃ©nÃ©rer des revenus rÃ©guliers.")
    print()

    # Calls OTM courts termes
    covered_calls = df_results[
        (df_results['Status'].isin(['ATM', 'OTM'])) &
        (df_results['MaturitÃ© (mois)'] <= 3)
    ].sort_values('MaturitÃ© (mois)')

    print("   ğŸ“‹ CALLS Ã€ VENDRE (Covered Calls):")
    for i, (idx, row) in enumerate(covered_calls.head(5).iterrows(), 1):
        annualized_return = (row['Call EuropÃ©en'] / S0) * (12 / row['MaturitÃ© (mois)']) * 100

        print(f"   {i}. Vendre Call EuropÃ©en")
        print(f"      - Strike: ${row['Strike']:.2f} ({row['Status']}) - {((row['Strike']/S0)-1)*100:.1f}% au-dessus du prix actuel")
        print(f"      - MaturitÃ©: {int(row['MaturitÃ© (mois)'])} mois")
        print(f"      - Prime reÃ§ue: ${row['Call EuropÃ©en']:.2f}")
        print(f"      - Revenu annualisÃ©: {annualized_return:.2f}% du prix de l'action")
        print(f"      - Pour 100 actions: ${row['Call EuropÃ©en']*100:.2f} de revenu")
        print()

    print("   ğŸ’¡ CONSEIL:")
    print("      - Vendre des calls OTM (5-10% au-dessus du prix actuel)")
    print("      - Renouveler chaque mois ou trimestre")
    print("      - Accepter que les actions puissent Ãªtre appelÃ©es si prix > strike")
    print("      - Combiner avec dividendes Nintendo pour revenu total optimisÃ©")
    print()

else:  # VOLATILITÃ‰
    print("ğŸ¯ STRATÃ‰GIE SUR VOLATILITÃ‰ (STRADDLE/STRANGLE):")
    print()
    print("   Vous anticipez un mouvement important sans savoir la direction.")
    print()

    # Straddle ATM
    straddles = df_results[df_results['Status'] == 'ATM'].copy()
    straddles['Straddle Cost'] = straddles['Call EuropÃ©en'] + straddles['Put EuropÃ©en']
    straddles['Breakeven Low'] = straddles['Strike'] - straddles['Straddle Cost']
    straddles['Breakeven High'] = straddles['Strike'] + straddles['Straddle Cost']

    print("   ğŸ“‹ STRADDLES RECOMMANDÃ‰S (Call + Put ATM):")
    for i, (idx, row) in enumerate(straddles.head(3).iterrows(), 1):
        move_required = (row['Straddle Cost'] / S0) * 100

        print(f"   {i}. Straddle (Achat Call + Put)")
        print(f"      - Strike: ${row['Strike']:.2f}")
        print(f"      - MaturitÃ©: {int(row['MaturitÃ© (mois)'])} mois")
        print(f"      - CoÃ»t total: ${row['Straddle Cost']:.2f}")
        print(f"      - Points morts: ${row['Breakeven Low']:.2f} - ${row['Breakeven High']:.2f}")
        print(f"      - Mouvement requis: Â±{move_required:.1f}%")
        print(f"      - Vega (sensibilitÃ© volatilitÃ©): {row['Call Vega']:.3f}")
        print()

    print("   ğŸ’¡ CONSEIL:")
    print("      - Profitable si mouvement > coÃ»t du straddle")
    print("      - BÃ©nÃ©ficie d'une hausse de volatilitÃ© implicite")
    print("      - Ã€ privilÃ©gier avant annonces importantes (rÃ©sultats, nouveaux jeux)")
    print()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 9: ANALYSE DE SCÃ‰NARIOS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("=" * 80)
print("  ANALYSE DE SCÃ‰NARIOS - PROFIT & LOSS")
print("=" * 80)
print()

# SÃ©lection d'une option reprÃ©sentative pour analyse P&L
if 'call' in option_types_focus:
    # Call ATM, maturitÃ© mÃ©diane
    atm_calls = df_results[df_results['Status'] == 'ATM']
    if not atm_calls.empty:
        representative_call = atm_calls.iloc[len(atm_calls)//2]
        K_call = representative_call['Strike']
        premium_call = representative_call['Call EuropÃ©en']
        T_call = representative_call['MaturitÃ© (annÃ©es)']

        # Plage de prix Ã  maturitÃ©
        price_range = np.linspace(S0 * 0.5, S0 * 1.5, 100)

        # Calcul du P&L pour Long Call
        payoff_call = np.maximum(price_range - K_call, 0) - premium_call

        # Breakeven
        breakeven_call = K_call + premium_call

        # Visualisation
        fig_pl_call = go.Figure()

        fig_pl_call.add_trace(go.Scatter(
            x=price_range,
            y=payoff_call,
            name='Long Call P&L',
            line=dict(color='green', width=3),
            fill='tozeroy',
            fillcolor='rgba(0,255,0,0.1)'
        ))

        fig_pl_call.add_hline(y=0, line_dash="solid", line_color="black", line_width=2)
        fig_pl_call.add_vline(x=S0, line_dash="dash", line_color="blue",
                             annotation_text=f"Prix actuel: ${S0:.2f}")
        fig_pl_call.add_vline(x=breakeven_call, line_dash="dash", line_color="red",
                             annotation_text=f"Point mort: ${breakeven_call:.2f}")

        fig_pl_call.update_layout(
            title=f'Profit & Loss: Long Call (Strike ${K_call:.2f}, Prime ${premium_call:.2f})<br>Profil {profil["nom"]} reverdure',
            xaxis_title='Prix de Nintendo Ã  maturitÃ© ($)',
            yaxis_title='Profit / Perte ($)',
            hovermode='x',
            height=600
        )

        fig_pl_call.show()
        print(f"ğŸ“Š Graphique interactif: P&L Long Call (Strike ${K_call:.2f}) gÃ©nÃ©rÃ©")
    else:
        print("ğŸ’¡ Pas de Call ATM trouvÃ© pour l'analyse P&L pour le profil actuel.")

if 'put' in option_types_focus:
    atm_puts = df_results[df_results['Status'] == 'ATM']
    if not atm_puts.empty:
        representative_put = atm_puts.iloc[len(atm_puts)//2]
        K_put = representative_put['Strike']
        premium_put = representative_put['Put EuropÃ©en']
        T_put = representative_put['MaturitÃ© (annÃ©es)']

        price_range = np.linspace(S0 * 0.5, S0 * 1.5, 100)

        payoff_put = np.maximum(K_put - price_range, 0) - premium_put
        breakeven_put = K_put - premium_put

        fig_pl_put = go.Figure()

        fig_pl_put.add_trace(go.Scatter(
            x=price_range,
            y=payoff_put,
            name='Long Put P&L',
            line=dict(color='red', width=3),
            fill='tozeroy',
            fillcolor='rgba(255,0,0,0.1)'
        ))

        fig_pl_put.add_hline(y=0, line_dash="solid", line_color="black", line_width=2)
        fig_pl_put.add_vline(x=S0, line_dash="dash", line_color="blue",
                            annotation_text=f"Prix actuel: ${S0:.2f}")
        fig_pl_put.add_vline(x=breakeven_put, line_dash="dash", line_color="red",
                            annotation_text=f"Point mort: ${breakeven_put:.2f}")

        fig_pl_put.update_layout(
            title=f'Profit & Loss: Long Put (Strike ${K_put:.2f}, Prime ${premium_put:.2f})<br>Profil {profil["nom"]}',
            xaxis_title='Prix de Nintendo Ã  maturitÃ© ($)',
            yaxis_title='Profit / Perte ($)',
            hovermode='x',
            height=600
        )

        fig_pl_put.show()
        print(f"ğŸ“Š Graphique interactif: P&L Long Put (Strike ${K_put:.2f}) gÃ©nÃ©rÃ©")
    else:
        print("ğŸ’¡ Pas de Put ATM trouvÃ© pour l'analyse P&L pour le profil actuel.")

print()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 10: TABLEAU RÃ‰CAPITULATIF FINAL
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("=" * 80)
print("  TABLEAU RÃ‰CAPITULATIF - MEILLEURES OPPORTUNITÃ‰S")
print("=" * 80)
print()

# CrÃ©ation d'un tableau rÃ©capitulatif selon le profil
summary_options = []

if 'call' in option_types_focus:
    # Top 3 Calls selon le profil
    if PROFIL_INVESTISSEUR in [2, 4]:  # Haussier ou Revenus
        top_calls = df_results.nsmallest(3, 'Call EuropÃ©en')
        for _, row in top_calls.iterrows():
            summary_options.append({
                'Type': 'Call EuropÃ©en',
                'Strike': f"${row['Strike']:.2f}",
                'MaturitÃ©': f"{int(row['MaturitÃ© (mois)'])} mois",
                'Prix': f"${row['Call EuropÃ©en']:.2f}",
                'Delta': f"{row['Call Delta']:.3f}",
                'Status': row['Status'],
                'Usage': 'SpÃ©culation haussiÃ¨re' if PROFIL_INVESTISSEUR == 2 else 'Vente couverte'
            })

if 'put' in option_types_focus:
    # Top 3 Puts selon le profil
    if PROFIL_INVESTISSEUR in [1, 3]:  # Couverture ou Baissier
        top_puts = df_results.nsmallest(3, 'Put EuropÃ©en')
        for _, row in top_puts.iterrows():
            summary_options.append({
                'Type': 'Put EuropÃ©en',
                'Strike': f"${row['Strike']:.2f}",
                'MaturitÃ©': f"{int(row['MaturitÃ© (mois)'])} mois",
                'Prix': f"${row['Put EuropÃ©en']:.2f}",
                'Delta': f"{row['Put Delta']:.3f}",
                'Status': row['Status'],
                'Usage': 'Protection (Hedge)' if PROFIL_INVESTISSEUR == 1 else 'SpÃ©culation baissiÃ¨re'
            })

if summary_options:
    df_summary = pd.DataFrame(summary_options)
    print(df_summary.to_string(index=False))
    print()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 11: CONSEILS FINAUX ET AVERTISSEMENTS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("=" * 80)
print("  CONSEILS FINAUX POUR L'INVESTISSEUR")
print("=" * 80)
print()

print(f"ğŸ¯ PROFIL: {profil['nom']}")
print(f"   StratÃ©gie principale: {profil['strategie_principale']}")
print()

print("ğŸ’¡ POINTS CLÃ‰S Ã€ RETENIR:")
print()
print("   1. TIMING:")
print("      - Les options sont des actifs Ã  durÃ©e de vie limitÃ©e")
print(f"      - Horizon recommandÃ©: {profil['horizon_typique']}")
print("      - La valeur temps dÃ©croÃ®t exponentiellement proche de la maturitÃ© (Theta)")
print()

print("   2. GESTION DU RISQUE:")
print("      - Options d'achat (Calls/Puts): Risque limitÃ© Ã  la prime payÃ©e")
print("      - Options de vente: Risque potentiellement illimitÃ© (ne pas vendre d'options nues)")
print("      - Utiliser les Greeks pour surveiller les sensibilitÃ©s")
print(f"      - Delta target pour votre profil: {profil['delta_target']}")
print()

print("   3. VOLATILITÃ‰:")
print(f"      - VolatilitÃ© historique Nintendo: {volatility_hist*100:.2f}%")
print("      - Vega positif: vous profitez d'une hausse de volatilitÃ©")
print("      - ConsidÃ©rer la volatilitÃ© implicite du marchÃ© (non capturÃ©e ici)")
print()

print("   4. COÃ›TS DE TRANSACTION:")
print("      - Les prix indiquÃ©s sont thÃ©oriques (mid-market)")
print("      - PrÃ©voir spread bid-ask + commissions courtier")
print("      - Impact sur petites positions peut Ãªtre significatif")
print()

print("   5. FISCALITÃ‰:")
print("      - Traitement fiscal des options peut diffÃ©rer des actions")
print("      - Consulter un conseiller fiscal pour votre juridiction")
print()

print("   6. DIVERSIFICATION:")
print("      - Ne pas concentrer tout le capital sur options d'une seule sociÃ©tÃ©")
print("      - Les options sont des produits dÃ©rivÃ©s Ã  risque Ã©levÃ©")
print("      - Combiner avec stratÃ©gie diversifiÃ©e sur sous-jacents")
print()

print("âš ï¸  AVERTISSEMENTS:")
print()
print("   - Les modÃ¨les utilisÃ©s (Black-Scholes, Binomial) reposent sur des hypothÃ¨ses")
print("     simplificatrices (volatilitÃ© constante, pas de dividendes, etc.)")
print("   - Les performances passÃ©es ne prÃ©jugent pas des performances futures")
print("   - Les prix rÃ©els de marchÃ© peuvent diffÃ©rer des prix thÃ©oriques")
print("   - Options = produits complexes rÃ©servÃ©s Ã  investisseurs avertis")
print("   - Toujours comprendre parfaitement un produit avant d'investir")
print()

print("=" * 80)
print("  FIN DE L'ANALYSE - OPTION PRICING")
print("=" * 80)
print()

print("ğŸ“Š FICHIERS DE SORTIE RECOMMANDÃ‰S:")
print("   - Exporter df_results en CSV pour analyse approfondie")
print("   - Sauvegarder les graphiques interactifs en HTML")
print("   - CrÃ©er un rapport PDF avec les recommandations personnalisÃ©es")
print()

# Option d'export (dÃ©commenter si nÃ©cessaire)
# df_results.to_csv('nintendo_options_analysis.csv', index=False)
# fig_3d_call.write_html('nintendo_call_surface.html')
# fig_3d_put.write_html('nintendo_put_surface.html')

print("âœ… Analyse complÃ¨te terminÃ©e avec succÃ¨s!")