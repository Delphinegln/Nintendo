# -*- coding: utf-8 -*-
"""Partie 1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1S0rg3k8v8AvDr2u66TOQ7Y3DsuJjP3j7

# Financial **Forecasting**

## Data preparation and **Setup**
"""

# --- Imports ---
import yfinance as yf
from prophet import Prophet
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from scipy import stats
import math
import numpy.random as npr

# --- Plot style ---
sns.set_theme(context="notebook", style="whitegrid")
plt.rcParams.update({
    "figure.figsize": (12, 6),
    "axes.titlesize": 14,
    "axes.labelsize": 12,
    "xtick.labelsize": 10,
    "ytick.labelsize": 10,
    "legend.frameon": False,
    "figure.autolayout": True,
})

# --- Date range for data extraction ---
start = "2015-09-30"
end   = "2025-09-30"

# --- Ticker -> Company name mapping ---
companies = {
    "NTDOY": "Nintendo Co., Ltd.",
    "SONY": "Sony Group Corporation",
    "MSFT":   "Microsoft Corporation",
    "EA":     "Electronic Arts Inc.",
    "TCEHY": "Tencent Holdings Corporation"
}

"""Ce bloc de code prépare l'environnement pour l'analyse et la visualisation de données financières. Il importe les bibliothèques nécessaires, configure les styles de traçage et définit des variables importantes pour l'extraction de données.

Dans le même temps, nous définissons les entreprises à étudier à savoir Nintendo (NTDOY) et ses concurrents (Nintendo Co., Ltd., Sony Group Corporation, Microsoft Corporation, Electronic Arts Inc., Tencent Holdings Corporation).

## Data Extraction and Historical Analysis

### Retrieving Financial Data
"""

# ---------- 1) Détails financiers Nintendo ----------
ntd_ticker = "NTDOY"
ntd = yf.Ticker(ntd_ticker)

# Annual Financial Statements
balance_sheet = ntd.balance_sheet
income_stmt   = ntd.income_stmt
cashflow_stmt = ntd.cashflow

# Dividends
# Convertir les dates de début et de fin en objets datetime sensibles au fuseau horaire 'Asia/Tokyo'
# pour correspondre au fuseau horaire de l'index des dividendes.
start_ts = pd.to_datetime(start).tz_localize('Asia/Tokyo')
end_ts = pd.to_datetime(end).tz_localize('Asia/Tokyo')
div_all = ntd.dividends
div_period = div_all.loc[(div_all.index >= start_ts) & (div_all.index <= end_ts)]


# Affichages
print("=== NINTENDO (NTDOY) — Balance Sheet ===")
# Set display options to show all rows and columns
pd.set_option('display.max_columns', None)
pd.set_option('display.max_rows', None)
display(balance_sheet)
# Reset display options to default
pd.reset_option('display.max_columns')
pd.reset_option('display.max_rows')

print("\n=== NINTENDO (NTDOY) — Income Statement ===")
pd.set_option('display.max_columns', None)
pd.set_option('display.max_rows', None)
display(income_stmt)
pd.reset_option('display.max_columns')
pd.reset_option('display.max_rows')

print("\n=== NINTENDO (NTDOY) — Cash Flow Statement ===")
pd.set_option('display.max_columns', None)
pd.set_option('display.max_rows', None)
display(cashflow_stmt)
pd.reset_option('display.max_columns')
pd.reset_option('display.max_rows')

print("\n=== NINTENDO (NTDOY) — Dividends ===")
display(div_period.to_frame(name="Dividend per share"))

"""### Historical Analysis"""

# ---------- 2) Historical Prices ----------
tickers = list(companies.keys())
prices = yf.download(tickers, start=start, end=end, progress=False)["Close"] # Changed 'Adj Close' to 'Close'

# Forcer DataFrame si un seul ticker
if isinstance(prices, pd.Series):
    prices = prices.to_frame()

# ---------- 3) Normalisation (base 100 au premier point valide) ----------
def base100(df: pd.DataFrame) -> pd.DataFrame:
    def norm_col(s):
        if s.dropna().empty:
            return s
        first_val = s.dropna().iloc[0]
        return (s / first_val) * 100.0
    return df.apply(norm_col, axis=0)

px_norm = base100(prices.copy())

# Renommer colonnes avec noms lisibles
px_norm = px_norm.rename(columns={t: companies.get(t, t) for t in px_norm.columns})

# ---------- 4) Visualisation performance relative ----------
ax = px_norm.plot(figsize=(12, 6), lw=1.8)
ax.set_title(f"Performance relative (base 100) — {start_ts.date()} → {end_ts.date()}")
ax.set_xlabel("Date")
ax.set_ylabel("Index (base 100)")
ax.grid(True, alpha=0.3)
plt.legend(title="Entreprise", ncol=2, frameon=False)
plt.show()

#Download stock data and calculating the returns

stocks = ['NTDOY', 'TCEHY', 'SONY', 'MSFT',"EA"]
prices = yf.download(stocks, start='2020-01-01', end='2024-12-31')['Close']
returns = prices.pct_change().dropna()

r = returns["NTDOY"].mean() #Calculate mean return
sigma = returns["NTDOY"].std() # std of returns

M = 100 #the number of time intervals for the discretization
T = 5.0
dt = T / M

I = 10000

S = np.zeros((M + 1, I))
S0 = prices["NTDOY"].loc["2024-12-30"]
S[0] = S0

for t in range(1, M + 1):
    S[t] = S[t-1] * np.exp((r - 0.5 * sigma ** 2) * dt + sigma * math.sqrt(dt) * npr.standard_normal(I))

# Using Plotly for interactive plot
import plotly.graph_objects as go

fig = go.Figure()

for i in range(I):
    fig.add_trace(go.Scatter(y=S[:, i], mode='lines', name=f'Simulation {i+1}', showlegend=False,
                             line=dict(width=1, color='lightblue')))

# Adding the mean trajectory for better visualization
fig.add_trace(go.Scatter(y=np.mean(S, axis=1), mode='lines', name='Mean Trajectory',
                         line=dict(width=2, color='darkblue')))

fig.update_layout(
    title='Monte Carlo Simulation of NTDOY Stock Price',
    xaxis_title='Time Step',
    yaxis_title='Stock Price',
    height=600,
    width=1000
)

fig.show()

"""## Financial forecasting with Prophet
Time series analysis
"""

import cmdstanpy, os

cmdstanpy.install_cmdstan(overwrite=True)
cmdstan_path = cmdstanpy.cmdstan_path()
os.environ["CMDSTAN"] = cmdstan_path

print(f"Prophet sera forcé à utiliser CmdStan depuis : {cmdstan_path}")

prophet_dir = "/usr/local/lib/python3.12/dist-packages/prophet/stan_model/cmdstan-2.33.1"
if os.path.exists(prophet_dir):
    import shutil
    print(f"Suppression de l'ancienne installation défectueuse : {prophet_dir}")
    shutil.rmtree(prophet_dir, ignore_errors=True)
else:
    print("Aucun ancien dossier cassé trouvé dans Prophet.")

print(f"\nCmdStan en cours : {cmdstanpy.cmdstan_path()}")

# Change the index column and rename it
income_stmt.reset_index(inplace=True)
income_stmt.rename(columns={'index':'Metric'}, inplace=True)

# Melt the DataFrame to transform date columns to the single 'Date' column
income_stmt = income_stmt.melt(id_vars=['Metric'], var_name='Date', value_name='Value')

# Convert 'Date' column to datetime format
income_stmt['Date'] = pd.to_datetime(income_stmt['Date'])

# Now, df has the required structure for Prophet
income_stmt

# Create an empty DataFrame to store the forecasts for all metrics
all_forecasts = pd.DataFrame()

# Get unique metric names from the data
unique_metrics = income_stmt['Metric'].unique()

# Iterate through each unique metric and create forecasts
for metric in unique_metrics:
    # Select data for the specific metric
    metric_data = income_stmt[income_stmt['Metric'] == metric].drop(columns='Metric')

    # Rename columns to 'ds' and 'y' as strictly imposed by Prophet
    metric_data.rename(columns={'Date': 'ds', 'Value': 'y'}, inplace=True)

    # Create and fit the Prophet model
    prophet_model = Prophet()
    prophet_model.fit(metric_data)

    # Create a future dataframe for 5 years
    future = prophet_model.make_future_dataframe(periods=5*1, freq='Y')  # 5 years with yearly frequency

    # Make the forecast
    forecast = prophet_model.predict(future)

    # Add the forecasted values to the 'all_forecasts' DataFrame
    forecast['Metric'] = metric
    all_forecasts = pd.concat([all_forecasts, forecast[['ds', 'Metric', 'yhat', 'yhat_lower', 'yhat_upper']]])

# Prophet returns a large DataFrame with many interesting columns, but we subset our output to the columns most relevant to forecasting. These are:

# ds: the datestamp of the forecasted value
# yhat: the forecasted value of our metric (in Statistics, yhat is a notation traditionally used to represent the predicted values of a value y)
# yhat_lower: the lower bound of our forecasts
# yhat_upper: the upper bound of our forecasts

# Display the forecasts for all metrics in millions
all_forecasts_millions = all_forecasts.copy()
all_forecasts_millions['yhat'] = all_forecasts_millions['yhat'] / 1_000_000
all_forecasts_millions['yhat_lower'] = all_forecasts_millions['yhat_lower'] / 1_000_000
all_forecasts_millions['yhat_upper'] = all_forecasts_millions['yhat_upper'] / 1_000_000

all_forecasts_millions

# Look at the projection of a specific metric
all_forecasts[all_forecasts['Metric'] == 'Total Revenue']

import plotly.graph_objects as go
import plotly.colors
from plotly.subplots import make_subplots

chosen_metrics = ['Total Revenue', 'Total Expenses', 'Net Income',
                  'Operating Income']

chosen_metrics_forecasts = all_forecasts[all_forecasts['Metric'].isin(chosen_metrics)].copy()

base_colors = plotly.colors.qualitative.Plotly

# ---------- FAN CHART INTERACTIF ----------
fig_fan = go.Figure()

for i, metric in enumerate(chosen_metrics):
    df_m = chosen_metrics_forecasts[chosen_metrics_forecasts['Metric'] == metric].copy()
    color = base_colors[i % len(base_colors)]
    visible = (i == 0)

    fig_fan.add_trace(go.Scatter(
        x=df_m['ds'],
        y=df_m['yhat_upper'],
        mode='lines',
        line=dict(width=0),
        showlegend=False,
        hoverinfo='skip',
        visible=visible
    ))

    fig_fan.add_trace(go.Scatter(
        x=df_m['ds'],
        y=df_m['yhat_lower'],
        mode='lines',
        line=dict(width=0),
        fill='tonexty',
        fillcolor='rgba(0, 0, 150, 0.15)',
        showlegend=False,
        hoverinfo='skip',
        visible=visible
    ))

    fig_fan.add_trace(go.Scatter(
        x=df_m['ds'],
        y=df_m['yhat'],
        mode='lines',
        name=metric,
        line=dict(width=2, color=color),
        hovertemplate=f'<b>{metric}</b><br>Valeur: %{{y:,.0f}}<br>Date: %{{x|%Y-%m-%d}}<extra></extra>',
        visible=visible
    ))

buttons = []
for i, metric in enumerate(chosen_metrics):
    visibility = [False] * (3 * len(chosen_metrics))
    visibility[3 * i] = True
    visibility[3 * i + 1] = True
    visibility[3 * i + 2] = True
    buttons.append(
        dict(
            label=metric,
            method='update',
            args=[
                {'visible': visibility},
                {'title': f'<b>Prévision {metric} (fan chart)</b>'}
            ]
        )
    )

fig_fan.update_layout(
    title={'text': f'<b>Prévision {chosen_metrics[0]} (fan chart)</b>', 'x': 0.5, 'xanchor': 'center'},
    xaxis_title='Date',
    yaxis_title='Valeur',
    template='plotly_white',
    hovermode='x unified',
    height=500,
    width=900,
    updatemenus=[
        dict(
            type='dropdown',
            direction='down',
            showactive=True,
            x=0.5,
            xanchor='center',
            y=1.15,
            yanchor='top',
            buttons=buttons
        )
    ]
)

fig_fan.show()

"""# Scenario Analysis"""

# =========================
#       SCENARIO ANALYSIS
# =========================

import numpy as np
import plotly.graph_objects as go
import plotly.colors

# ---------- 1) Paramètres généraux des scénarios ----------

scenario_factors = {
    "Central": 1.00,
    "Optimistic": 1.15,   # +15%
    "Pessimistic": 0.85   # -15%
}

base_colors = plotly.colors.qualitative.Plotly

# On cible ces KPI, mais on ne garde que ceux réellement présents
target_metrics = [
    "Total Revenue",
    "Operating Income",
    "Net Income",
    "Operating Cash Flow"
]

available_metrics = all_forecasts_millions["Metric"].unique()
scenario_metrics = [m for m in target_metrics if m in available_metrics]


# ---------- 2) Construction des scénarios pour les KPI ----------

kpi_scenarios = []

for metric in scenario_metrics:
    hist_mask = income_stmt["Metric"] == metric
    last_hist_date = income_stmt.loc[hist_mask, "Date"].max()

    df_forecast = all_forecasts_millions[
        (all_forecasts_millions["Metric"] == metric)
        & (all_forecasts_millions["ds"] > last_hist_date)
    ].copy()

    if df_forecast.empty:
        continue

    for scen_name, factor in scenario_factors.items():
        tmp = df_forecast[["ds", "Metric", "yhat"]].copy()
        tmp["Scenario"] = scen_name
        tmp["Value"] = tmp["yhat"] * factor
        kpi_scenarios.append(tmp)

kpi_scenarios = pd.concat(kpi_scenarios, ignore_index=True)


# ---------- 3) Graphique interactif des scénarios KPI ----------

fig_kpi = go.Figure()

for i, metric in enumerate(scenario_metrics):
    df_metric = kpi_scenarios[kpi_scenarios["Metric"] == metric]
    color = base_colors[i % len(base_colors)]
    visible = (i == 0)

    for j, scen_name in enumerate(scenario_factors.keys()):
        df_scen = df_metric[df_metric["Scenario"] == scen_name]
        fig_kpi.add_trace(
            go.Scatter(
                x=df_scen["ds"],
                y=df_scen["Value"],
                mode="lines",
                name=f"{metric} – {scen_name}",
                line=dict(
                    width=2,
                    color=color,
                    dash=["solid", "dash", "dot"][j % 3]
                ),
                visible=visible,
                hovertemplate=(
                    f"<b>{metric} – {scen_name}</b><br>"
                    "Valeur (M): %{y:,.1f}<br>Date: %{x|%Y-%m-%d}"
                    "<extra></extra>"
                )
            )
        )

# bouton par KPI (3 traces par KPI)
buttons_kpi = []
for i, metric in enumerate(scenario_metrics):
    visibility = [False] * (len(scenario_metrics) * len(scenario_factors))
    start = i * len(scenario_factors)
    for k in range(len(scenario_factors)):
        visibility[start + k] = True

    buttons_kpi.append(
        dict(
            label=metric,
            method="update",
            args=[
                {"visible": visibility},
                {"title": f"<b>Scenario Analysis – {metric}</b>"}
            ]
        )
    )

fig_kpi.update_layout(
    title={"text": f"<b>Scenario Analysis – {scenario_metrics[0]}</b>", "x": 0.5, "xanchor": "center"},
    xaxis_title="Date",
    yaxis_title="Valeur (en millions)",
    template="plotly_white",
    hovermode="x unified",
    height=550,
    width=950,
    updatemenus=[
        dict(
            type="dropdown",
            direction="down",
            showactive=True,
            x=0.5,
            xanchor="center",
            y=1.15,
            yanchor="top",
            buttons=buttons_kpi
        )
    ]
)

fig_kpi.show()


# ---------- 4) Scénarios pour le prix NTDOY (à partir de S) ----------

# S : matrice (M+1, I) déjà calculée dans la partie Monte Carlo
# On extrait trois trajectoires représentatives via quantiles
time_steps = np.arange(S.shape[0])

pess_path = np.quantile(S, 0.20, axis=1)   # scénario défavorable
central_path = np.quantile(S, 0.50, axis=1)  # médian
optim_path = np.quantile(S, 0.80, axis=1)  # scénario favorable

fig_stock = go.Figure()

fig_stock.add_trace(
    go.Scatter(
        x=time_steps,
        y=central_path,
        mode="lines",
        name="Central",
        line=dict(width=2, color=base_colors[0]),
        hovertemplate="Step %{x}<br>Prix: %{y:,.2f}<extra></extra>"
    )
)

fig_stock.add_trace(
    go.Scatter(
        x=time_steps,
        y=optim_path,
        mode="lines",
        name="Optimistic",
        line=dict(width=2, color=base_colors[1], dash="dash"),
        hovertemplate="Step %{x}<br>Prix: %{y:,.2f}<extra></extra>"
    )
)

fig_stock.add_trace(
    go.Scatter(
        x=time_steps,
        y=pess_path,
        mode="lines",
        name="Pessimistic",
        line=dict(width=2, color=base_colors[2], dash="dot"),
        hovertemplate="Step %{x}<br>Prix: %{y:,.2f}<extra></extra>"
    )
)

fig_stock.update_layout(
    title={"text": "<b>Scenario Analysis – NTDOY Monte Carlo</b>", "x": 0.5, "xanchor": "center"},
    xaxis_title="Time step (horizon Monte Carlo)",
    yaxis_title="NTDOY Stock Price",
    template="plotly_white",
    height=550,
    width=950,
    legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1)
)

fig_stock.show()