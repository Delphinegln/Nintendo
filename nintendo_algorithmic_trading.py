# -*- coding: utf-8 -*-
"""Nintendo - Algorithmic trading.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1su2vOTQrQGATpNNFdNhMOAH3k4VXmGg0

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    ALGORITHMIC TRADING STRATEGIES FOR NINTENDO (NTDOY)
    PÃ©riode: Septembre 2015 - Septembre 2025

    StratÃ©gies implÃ©mentÃ©es:
    1. Simple Moving Averages (SMA) avec optimisation
    2. Vectorized Backtesting
    3. Regression-based Strategy (OLS)
    4. K-means Clustering (Machine Learning)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
""
"""

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 1: IMPORTS ET CONFIGURATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
import seaborn as sns
from itertools import product
from sklearn.linear_model import LinearRegression
from sklearn.cluster import KMeans
import warnings
warnings.filterwarnings('ignore')

# Configuration des graphiques
plt.style.use('seaborn-v0_8-whitegrid')
sns.set_palette("husl")
plt.rcParams['figure.figsize'] = (14, 8)
plt.rcParams['font.size'] = 11

print("=" * 80)
print("  ALGORITHMIC TRADING STRATEGIES - NINTENDO (NTDOY)")
print("=" * 80)
print()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 2: RÃ‰CUPÃ‰RATION DES DONNÃ‰ES NINTENDO
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("ðŸ“¥ TÃ©lÃ©chargement des donnÃ©es Nintendo...")

# Nintendo est cotÃ© sous le ticker NTDOY sur le marchÃ© US (ADR)
ticker = "NTDOY"
start_date = "2015-09-01"
end_date = "2025-09-30"

# TÃ©lÃ©chargement des donnÃ©es
nintendo_data = yf.download(ticker, start=start_date, end=end_date)
data = nintendo_data['Close']
data.columns = ['Close']

print(f"âœ… DonnÃ©es tÃ©lÃ©chargÃ©es: {len(data)} jours de trading")
print(f"   PÃ©riode: {data.index[0].strftime('%Y-%m-%d')} Ã  {data.index[-1].strftime('%Y-%m-%d')}")
print(f"   Prix initial: ${data['Close'].iloc[0]:.2f}")
print(f"   Prix final: ${data['Close'].iloc[-1]:.2f}")
print(f"   Performance totale: {((data['Close'].iloc[-1]/data['Close'].iloc[0])-1)*100:.2f}%")
print()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 3: STRATÃ‰GIE 1 - SIMPLE MOVING AVERAGES (SMA)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("=" * 80)
print("  STRATÃ‰GIE 1: SIMPLE MOVING AVERAGES (SMA)")
print("=" * 80)
print()

# ParamÃ¨tres SMA
SMA_SHORT = 42   # SMA court terme (environ 2 mois de trading)
SMA_LONG = 252   # SMA long terme (environ 1 an de trading)

# Calcul des SMAs
data['SMA_Short'] = data['Close'].rolling(SMA_SHORT).mean()
data['SMA_Long'] = data['Close'].rolling(SMA_LONG).mean()

# GÃ©nÃ©ration des signaux de trading
# Position = 1 (Long) quand SMA court > SMA long
# Position = -1 (Short) quand SMA court < SMA long
data.dropna(inplace=True)
data['Position'] = np.where(data['SMA_Short'] > data['SMA_Long'], 1, -1)

print(f"ðŸ“Š SMAs calculÃ©es:")
print(f"   - SMA court terme: {SMA_SHORT} jours")
print(f"   - SMA long terme: {SMA_LONG} jours")
print(f"   - Nombre de changements de position: {data['Position'].diff().ne(0).sum()}")
print()

# Visualisation des SMAs et positions
fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(15, 10), sharex=True)

# Graphique 1: Prix et SMAs
ax1.plot(data.index, data['Close'], label='Prix Nintendo', linewidth=2, alpha=0.8)
ax1.plot(data.index, data['SMA_Short'], label=f'SMA {SMA_SHORT}j', linewidth=1.5, alpha=0.8)
ax1.plot(data.index, data['SMA_Long'], label=f'SMA {SMA_LONG}j', linewidth=1.5, alpha=0.8)
ax1.set_ylabel('Prix ($)', fontsize=12, fontweight='bold')
ax1.set_title('Nintendo - Prix et Simple Moving Averages', fontsize=14, fontweight='bold', pad=20)
ax1.legend(loc='upper left', framealpha=0.9)
ax1.grid(True, alpha=0.3)

# Graphique 2: Positions de trading
ax2.plot(data.index, data['Position'], linewidth=2, color='darkblue')
ax2.fill_between(data.index, data['Position'], alpha=0.3, color='green',
                  where=(data['Position'] > 0), label='Long Position')
ax2.fill_between(data.index, data['Position'], alpha=0.3, color='red',
                  where=(data['Position'] < 0), label='Short Position')
ax2.set_ylabel('Position', fontsize=12, fontweight='bold')
ax2.set_xlabel('Date', fontsize=12, fontweight='bold')
ax2.set_title('Signaux de Trading (1=Long, -1=Short)', fontsize=14, fontweight='bold', pad=20)
ax2.legend(loc='upper left', framealpha=0.9)
ax2.grid(True, alpha=0.3)
ax2.set_ylim(-1.5, 1.5)

plt.tight_layout()
plt.savefig('nintendo_sma_strategy.png', dpi=300, bbox_inches='tight')
print("ðŸ“ˆ Graphique sauvegardÃ©: nintendo_sma_strategy.png")
print()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 4: VECTORIZED BACKTESTING
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("=" * 80)
print("  STRATÃ‰GIE 2: VECTORIZED BACKTESTING")
print("=" * 80)
print()

# Calcul des rendements logarithmiques
data['Returns'] = np.log(data['Close'] / data['Close'].shift(1))

# Calcul de la stratÃ©gie: dÃ©calage de 1 jour pour Ã©viter le look-ahead bias
data['Strategy'] = data['Position'].shift(1) * data['Returns']

# Suppression des NaN
data.dropna(inplace=True)

# Calcul des performances cumulÃ©es
cumulative_returns = np.exp(data[['Returns', 'Strategy']].sum())
annualized_volatility = data[['Returns', 'Strategy']].std() * np.sqrt(252)
sharpe_ratio = (data[['Returns', 'Strategy']].mean() * 252) / annualized_volatility

print("ðŸ“Š RÃ‰SULTATS DU BACKTESTING:")
print("-" * 80)
print(f"\n{'MÃ©trique':<40} {'Buy & Hold':<20} {'SMA Strategy':<20}")
print("-" * 80)
print(f"{'Performance cumulÃ©e':<40} {cumulative_returns['Returns']:<20.4f} {cumulative_returns['Strategy']:<20.4f}")
print(f"{'Performance %':<40} {(cumulative_returns['Returns']-1)*100:<20.2f}% {(cumulative_returns['Strategy']-1)*100:<20.2f}%")
print(f"{'VolatilitÃ© annualisÃ©e':<40} {annualized_volatility['Returns']:<20.4f} {annualized_volatility['Strategy']:<20.4f}")
print(f"{'Sharpe Ratio (sans rf)':<40} {sharpe_ratio['Returns']:<20.4f} {sharpe_ratio['Strategy']:<20.4f}")
print("-" * 80)

# Calcul du rendement annuel moyen
years = (data.index[-1] - data.index[0]).days / 365.25
annual_return_bh = (cumulative_returns['Returns'] ** (1/years)) - 1
annual_return_strat = (cumulative_returns['Strategy'] ** (1/years)) - 1

print(f"{'Rendement annuel moyen':<40} {annual_return_bh*100:<20.2f}% {annual_return_strat*100:<20.2f}%")
print(f"{'DurÃ©e du backtest (annÃ©es)':<40} {years:<20.2f}")
print()

# Visualisation des performances
fig, ax = plt.subplots(figsize=(15, 8))

# Calcul des performances cumulatives
cumulative_perf = data[['Returns', 'Strategy']].cumsum().apply(np.exp)

ax.plot(cumulative_perf.index, cumulative_perf['Returns'],
        label='Buy & Hold', linewidth=2.5, alpha=0.9)
ax.plot(cumulative_perf.index, cumulative_perf['Strategy'],
        label='SMA Strategy', linewidth=2.5, alpha=0.9)

# Ajout d'une ligne Ã  1 (investissement initial)
ax.axhline(y=1, color='gray', linestyle='--', linewidth=1, alpha=0.5, label='Investissement initial')

ax.set_xlabel('Date', fontsize=12, fontweight='bold')
ax.set_ylabel('Performance Cumulative', fontsize=12, fontweight='bold')
ax.set_title('Comparaison des Performances: Buy & Hold vs SMA Strategy',
             fontsize=14, fontweight='bold', pad=20)
ax.legend(loc='upper left', framealpha=0.9, fontsize=11)
ax.grid(True, alpha=0.3)

# Ajout d'annotations
max_bh = cumulative_perf['Returns'].max()
max_strat = cumulative_perf['Strategy'].max()
ax.text(0.02, 0.98, f'Max Buy & Hold: {max_bh:.2f}x\nMax Strategy: {max_strat:.2f}x',
        transform=ax.transAxes, fontsize=10, verticalalignment='top',
        bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.8))

plt.tight_layout()
plt.savefig('nintendo_backtest_performance.png', dpi=300, bbox_inches='tight')
print("ðŸ“ˆ Graphique sauvegardÃ©: nintendo_backtest_performance.png")
print()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 5: OPTIMISATION DES PARAMÃˆTRES SMA
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("=" * 80)
print("  OPTIMISATION DES PARAMÃˆTRES SMA (BRUTE FORCE)")
print("=" * 80)
print()

print("ðŸ” Recherche des meilleurs paramÃ¨tres SMA...")
print("   (Cette opÃ©ration peut prendre quelques secondes...)")

# Plages de paramÃ¨tres Ã  tester
sma_short_range = range(20, 81, 5)   # De 20 Ã  80 jours, pas de 5
sma_long_range = range(150, 301, 10)  # De 150 Ã  300 jours, pas de 10

# DataFrame pour stocker les rÃ©sultats
optimization_results = pd.DataFrame()

# Test de toutes les combinaisons
for SMA1, SMA2 in product(sma_short_range, sma_long_range):
    # Ã‰viter les cas oÃ¹ SMA court >= SMA long
    if SMA1 >= SMA2:
        continue

    # RÃ©initialisation des donnÃ©es
    temp_data = nintendo_data['Close']
    temp_data.columns = ['Close']
    temp_data.dropna(inplace=True)

    # Calcul des SMAs
    temp_data['SMA_Short'] = temp_data['Close'].rolling(SMA1).mean()
    temp_data['SMA_Long'] = temp_data['Close'].rolling(SMA2).mean()
    temp_data.dropna(inplace=True)

    # Calcul des positions et rendements
    temp_data['Position'] = np.where(temp_data['SMA_Short'] > temp_data['SMA_Long'], 1, -1)
    temp_data['Returns'] = np.log(temp_data['Close'] / temp_data['Close'].shift(1))
    temp_data['Strategy'] = temp_data['Position'].shift(1) * temp_data['Returns']
    temp_data.dropna(inplace=True)

    # Calcul des performances
    perf = np.exp(temp_data[['Returns', 'Strategy']].sum())

    # Stockage des rÃ©sultats
    result = pd.DataFrame({
        'SMA_Short': [SMA1],
        'SMA_Long': [SMA2],
        'Market_Return': [perf['Returns']],
        'Strategy_Return': [perf['Strategy']],
        'Outperformance': [perf['Strategy'] - perf['Returns']]
    })

    optimization_results = pd.concat([optimization_results, result], ignore_index=True)

# Tri des rÃ©sultats par outperformance
optimization_results.sort_values('Outperformance', ascending=False, inplace=True)

print(f"âœ… {len(optimization_results)} combinaisons testÃ©es")
print()
print("ðŸ† TOP 10 DES MEILLEURES COMBINAISONS:")
print("-" * 80)
print(optimization_results.head(10).to_string(index=False))
print()

# Meilleure combinaison
best_params = optimization_results.iloc[0]
print(f"â­ MEILLEURS PARAMÃˆTRES TROUVÃ‰S:")
print(f"   - SMA Court: {int(best_params['SMA_Short'])} jours")
print(f"   - SMA Long: {int(best_params['SMA_Long'])} jours")
print(f"   - Performance MarchÃ©: {best_params['Market_Return']:.4f}x ({(best_params['Market_Return']-1)*100:.2f}%) ÙØ±Øµ)")
print(f"   - Performance StratÃ©gie: {best_params['Strategy_Return']:.4f}x ({(best_params['Strategy_Return']-1)*100:.2f}%) ÙØ±Øµ)")
print(f"   - Surperformance: {best_params['Outperformance']:.4f} ({best_params['Outperformance']*100:.2f}%) ÙØ±Øµ)")
print()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 6: STRATÃ‰GIE BASÃ‰E SUR LA RÃ‰GRESSION (OLS)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("=" * 80)
print("  STRATÃ‰GIE 3: REGRESSION-BASED TRADING (OLS)")
print("=" * 80)
print()

# PrÃ©paration des donnÃ©es pour la rÃ©gression
regression_data = nintendo_data['Close']
regression_data.columns = ['Close']
regression_data['returns'] = np.log(regression_data['Close'] / regression_data['Close'].shift(1))

# CrÃ©ation des features (lags)
lags = 5
cols = []
for lag in range(1, lags + 1):
    col = f'lag_{lag}'
    regression_data[col] = regression_data['returns'].shift(lag)
    cols.append(col)

regression_data.dropna(inplace=True)

# Calcul de la direction APRÃˆS la suppression des NaN
regression_data['direction'] = np.sign(regression_data['returns']).astype(int)

print(f"ðŸ“Š RÃ©gression avec {lags} lags de rendements")
print(f"   Nombre d'observations: {len(regression_data)}")
print()

# ModÃ¨le 1: RÃ©gression sur les rendements
model_returns = LinearRegression()
regression_data['pred_returns'] = model_returns.fit(
    regression_data[cols],
    regression_data['returns']
).predict(regression_data[cols])

# ModÃ¨le 2: RÃ©gression sur la direction
model_direction = LinearRegression()
regression_data['pred_direction'] = model_direction.fit(
    regression_data[cols],
    regression_data['direction']
).predict(regression_data[cols])

# Conversion des prÃ©dictions en positions (-1 ou 1)
regression_data['pos_reg_returns'] = np.where(regression_data['pred_returns'] > 0, 1, -1)
regression_data['pos_reg_direction'] = np.where(regression_data['pred_direction'] > 0, 1, -1)

# Calcul des stratÃ©gies
regression_data['strat_reg_returns'] = regression_data['pos_reg_returns'] * regression_data['returns']
regression_data['strat_reg_direction'] = regression_data['pos_reg_direction'] * regression_data['returns']

# Calcul des performances
perf_regression = np.exp(regression_data[['returns', 'strat_reg_returns', 'strat_reg_direction']].sum())

print("ðŸ“Š RÃ‰SULTATS DES STRATÃ‰GIES DE RÃ‰GRESSION:")
print("-" * 80)
print(f"{'StratÃ©gie':<40} {'Performance':<20} {'% Gain':<20}")
print("-" * 80)
print(f"{'Buy & Hold':<40} {perf_regression['returns']:<20.4f} {(perf_regression['returns']-1)*100:<20.2f}%")
print(f"{'RÃ©gression sur Rendements':<40} {perf_regression['strat_reg_returns']:<20.4f} {(perf_regression['strat_reg_returns']-1)*100:<20.2f}%")
print(f"{'RÃ©gression sur Direction':<40} {perf_regression['strat_reg_direction']:<20.4f} {(perf_regression['strat_reg_direction']-1)*100:<20.2f}%")
print("-" * 80)

# PrÃ©cision des prÃ©dictions
accuracy_returns = (regression_data['direction'] == regression_data['pos_reg_returns']).sum() / len(regression_data)
accuracy_direction = (regression_data['direction'] == regression_data['pos_reg_direction']).sum() / len(regression_data)

print(f"\n{'PrÃ©cision des PrÃ©dictions:':<40}")
print(f"{'  ModÃ¨le sur Rendements':<40} {accuracy_returns*100:<20.2f}%")
print(f"{'  ModÃ¨le sur Direction':<40} {accuracy_direction*100:<20.2f}%")
print()

# Visualisation
fig, ax = plt.subplots(figsize=(15, 8))

cumulative_reg = regression_data[['returns', 'strat_reg_returns', 'strat_reg_direction']].cumsum().apply(np.exp)

ax.plot(cumulative_reg.index, cumulative_reg['returns'],
        label='Buy & Hold', linewidth=2.5, alpha=0.9)
ax.plot(cumulative_reg.index, cumulative_reg['strat_reg_returns'],
        label='RÃ©gression Rendements', linewidth=2, alpha=0.9)
ax.plot(cumulative_reg.index, cumulative_reg['strat_reg_direction'],
        label='RÃ©gression Direction', linewidth=2, alpha=0.9)

ax.axhline(y=1, color='gray', linestyle='--', linewidth=1, alpha=0.5)
ax.set_xlabel('Date', fontsize=12, fontweight='bold')
ax.set_ylabel('Performance Cumulative', fontsize=12, fontweight='bold')
ax.set_title('Performances des StratÃ©gies de RÃ©gression OLS', fontsize=14, fontweight='bold', pad=20)
ax.legend(loc='upper left', framealpha=0.9)
ax.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('nintendo_regression_strategies.png', dpi=300, bbox_inches='tight')
print("ðŸ“ˆ Graphique sauvegardÃ©: nintendo_regression_strategies.png")
print()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 7: K-MEANS CLUSTERING (MACHINE LEARNING)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("=" * 80)
print("  STRATÃ‰GIE 4: K-MEANS CLUSTERING (MACHINE LEARNING)")
print("=" * 80)
print()

# PrÃ©paration des donnÃ©es pour le clustering
clustering_data = regression_data[['returns', 'direction'] + cols].copy() # Added 'direction'

# Application du K-means avec 2 clusters
n_clusters = 2
kmeans = KMeans(n_clusters=n_clusters, random_state=42)
clustering_data['cluster'] = kmeans.fit_predict(clustering_data[cols])

# Conversion en position de trading
# Si cluster = 1, position = -1 (short), sinon position = 1 (long)
clustering_data['pos_cluster'] = np.where(clustering_data['cluster'] == 1, -1, 1)

# Calcul de la stratÃ©gie
clustering_data['strat_cluster'] = clustering_data['pos_cluster'] * clustering_data['returns']

# Performance
perf_cluster = np.exp(clustering_data[['returns', 'strat_cluster']].sum())

print("ðŸ“Š RÃ‰SULTATS DU K-MEANS CLUSTERING:")
print("-" * 80)
print(f"{'StratÃ©gie':<40} {'Performance':<20} {'% Gain':<20}")
print("-" * 80)
print(f"{'Buy & Hold':<40} {perf_cluster['returns']:<20.4f} {(perf_cluster['returns']-1)*100:<20.2f}%")
print(f"{'K-Means Strategy':<40} {perf_cluster['strat_cluster']:<20.4f} {(perf_cluster['strat_cluster']-1)*100:<20.2f}%")
print("-" * 80)

# PrÃ©cision
accuracy_cluster = (clustering_data['direction'] == clustering_data['pos_cluster']).sum() / len(clustering_data)
print(f"\n{'PrÃ©cision des PrÃ©dictions:':<40} {accuracy_cluster*100:<20.2f}%")
print(f"{'Nombre de trades':<40} {clustering_data['pos_cluster'].diff().ne(0).sum():<20}")
print()

# Visualisation des clusters
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))

# Graphique 1: Scatter plot des clusters
scatter = ax1.scatter(clustering_data['lag_1'], clustering_data['lag_2'],
                     c=clustering_data['cluster'], cmap='coolwarm', alpha=0.6, s=20)
ax1.set_xlabel('Lag 1 (Rendement J-1)', fontsize=11, fontweight='bold')
ax1.set_ylabel('Lag 2 (Rendement J-2)', fontsize=11, fontweight='bold')
ax1.set_title('Clusters IdentifiÃ©s par K-Means', fontsize=13, fontweight='bold', pad=15)
ax1.grid(True, alpha=0.3)
plt.colorbar(scatter, ax=ax1, label='Cluster')

# Graphique 2: Performance
cumulative_cluster = clustering_data[['returns', 'strat_cluster']].cumsum().apply(np.exp)
ax2.plot(cumulative_cluster.index, cumulative_cluster['returns'],
         label='Buy & Hold', linewidth=2.5, alpha=0.9)
ax2.plot(cumulative_cluster.index, cumulative_cluster['strat_cluster'],
         label='K-Means Strategy', linewidth=2.5, alpha=0.9)
ax2.axhline(y=1, color='gray', linestyle='--', linewidth=1, alpha=0.5)
ax2.set_xlabel('Date', fontsize=11, fontweight='bold')
ax2.set_ylabel('Performance Cumulative', fontsize=11, fontweight='bold')
ax2.set_title('Performance de la StratÃ©gie K-Means', fontsize=13, fontweight='bold', pad=15)
ax2.legend(loc='upper left', framealpha=0.9)
ax2.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('nintendo_kmeans_strategy.png', dpi=300, bbox_inches='tight')
print("ðŸ“ˆ Graphique sauvegardÃ©: nintendo_kmeans_strategy.png")
print()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 8: TABLEAU RÃ‰CAPITULATIF FINAL
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("=" * 80)
print("  TABLEAU RÃ‰CAPITULATIF - TOUTES LES STRATÃ‰GIES")
print("=" * 80)
print()

# Compilation des rÃ©sultats
summary = pd.DataFrame({
    'StratÃ©gie': [
        'Buy & Hold',
        f'SMA ({SMA_SHORT}/{SMA_LONG})',
        f'SMA OptimisÃ©e ({int(best_params["SMA_Short"])}/{int(best_params["SMA_Long"])})',
        'RÃ©gression Rendements',
        'RÃ©gression Direction',
        'K-Means Clustering'
    ],
    'Performance': [
        cumulative_returns['Returns'],
        cumulative_returns['Strategy'],
        best_params['Strategy_Return'],
        perf_regression['strat_reg_returns'],
        perf_regression['strat_reg_direction'],
        perf_cluster['strat_cluster']
    ],
    'VolatilitÃ©': [
        annualized_volatility['Returns'],
        annualized_volatility['Strategy'],
        np.nan,  # Non calculÃ© pour l'optimisation
        regression_data['strat_reg_returns'].std() * np.sqrt(252),
        regression_data['strat_reg_direction'].std() * np.sqrt(252),
        clustering_data['strat_cluster'].std() * np.sqrt(252)
    ],
    'Sharpe Ratio': [
        sharpe_ratio['Returns'],
        sharpe_ratio['Strategy'],
        np.nan,
        (regression_data['strat_reg_returns'].mean() * 252) / (regression_data['strat_reg_returns'].std() * np.sqrt(252)),
        (regression_data['strat_reg_direction'].mean() * 252) / (regression_data['strat_reg_direction'].std() * np.sqrt(252)),
        (clustering_data['strat_cluster'].mean() * 252) / (clustering_data['strat_cluster'].std() * np.sqrt(252))
    ]
})

summary['% Gain'] = (summary['Performance'] - 1) * 100
summary['Gain vs Buy&Hold'] = summary['Performance'] - summary['Performance'].iloc[0]

print(summary.to_string(index=False))
print()

print("=" * 80)
print("  RECOMMANDATIONS POUR LE CLIENT")
print("=" * 80)
print()

best_strategy_idx = summary['Performance'].iloc[1:].idxmax()
best_strategy = summary.loc[best_strategy_idx]

print(f"ðŸŽ¯ MEILLEURE STRATÃ‰GIE: {best_strategy['StratÃ©gie']}")
print(f"   - Performance: {best_strategy['Performance']:.4f}x ({best_strategy['% Gain']:.2f}%)")
print(f"   - Surperformance vs Buy&Hold: {best_strategy['Gain vs Buy&Hold']:.4f} ({best_strategy['Gain vs Buy&Hold']*100:.2f}%)")
if not np.isnan(best_strategy['Sharpe Ratio']):
    print(f"   - Sharpe Ratio: {best_strategy['Sharpe Ratio']:.4f}")
print()

print("ðŸ’¡ CONSEILS D'INVESTISSEMENT:")
print("   1. Les stratÃ©gies SMA offrent une bonne balance risque/rendement")
print("   2. L'optimisation des paramÃ¨tres peut significativement amÃ©liorer les performances")
print("   3. Les stratÃ©gies de Machine Learning (K-Means) montrent un potentiel intÃ©ressant")
print("   4. La volatilitÃ© des stratÃ©gies est gÃ©nÃ©ralement similaire au Buy & Hold")
print("   5. ConsidÃ©rer les coÃ»ts de transaction dans l'implÃ©mentation rÃ©elle")
print()

print("=" * 80)
print("  FIN DE L'ANALYSE - ALGORITHMIC TRADING")
print("=" * 80)