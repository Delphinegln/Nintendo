# -*- coding: utf-8 -*-
"""Nintendo - Algorithmic trading - V3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19fVZWX3WsOj82pnFwBVAj_camX4vJjoR
"""

# -*- coding: utf-8 -*-
"""
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    CONSEIL EN TRADING ALGORITHMIQUE - NINTENDO (NTDOY)
    PÃ©riode: Septembre 2015 - Septembre 2025

    StratÃ©gies pour investisseurs :
    1. Optimisation des paramÃ¨tres SMA (Simple Moving Averages)
    2. StratÃ©gie SMA optimisÃ©e avec backtesting vectorisÃ©
    3. StratÃ©gie basÃ©e sur la rÃ©gression (OLS)
    4. StratÃ©gie de Machine Learning (K-Means Clustering amÃ©liorÃ©)

    Approche personnalisÃ©e selon le profil d'investisseur
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 1: IMPORTS ET CONFIGURATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import numpy as np
import pandas as pd
import yfinance as yf
from itertools import product
from sklearn.linear_model import LinearRegression
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
import warnings
warnings.filterwarnings('ignore')

# BibliothÃ¨ques pour graphiques interactifs
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import plotly.express as px

print("=" * 80)
print("  CONSEIL EN TRADING ALGORITHMIQUE - NINTENDO (NTDOY)")
print("=" * 80)
print()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 2: RÃ‰CUPÃ‰RATION DES DONNÃ‰ES NINTENDO
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("ğŸ“¥ TÃ©lÃ©chargement des donnÃ©es Nintendo...")

ticker = "NTDOY"
start_date = "2015-09-01"
end_date = "2025-09-30"

# TÃ©lÃ©chargement des donnÃ©es
nintendo_data = yf.download(ticker, start=start_date, end=end_date, progress=False)
data_original = nintendo_data['Close']
data_original.columns = ['Close']

print(f"âœ… DonnÃ©es tÃ©lÃ©chargÃ©es: {len(data_original)} jours de trading")
print(f"   PÃ©riode: {data_original.index[0].strftime('%Y-%m-%d')} Ã  {data_original.index[-1].strftime('%Y-%m-%d')}")
print(f"   Prix initial: ${data_original['Close'].iloc[0]:.2f}")
print(f"   Prix final: ${data_original['Close'].iloc[-1]:.2f}")
print(f"   Performance totale: {((data_original['Close'].iloc[-1]/data_original['Close'].iloc[0])-1)*100:.2f}%")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 3: PROFIL D'INVESTISSEUR - PERSONNALISATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("=" * 80)
print("  PERSONNALISATION SELON VOTRE PROFIL D'INVESTISSEUR")
print("=" * 80)
print()
print("ğŸ“‹ Choisissez votre profil d'investisseur:")
print("   1. CONSERVATEUR : Minimisation du risque, frÃ©quence de trading faible")
print("   2. MODÃ‰RÃ‰ : Ã‰quilibre risque/rendement, frÃ©quence de trading moyenne")
print("   3. DYNAMIQUE : Maximisation du rendement, frÃ©quence de trading Ã©levÃ©e")
print("   4. PERSONNALISÃ‰ : DÃ©finir manuellement les paramÃ¨tres")
print()

# Configuration par dÃ©faut (modifiable)
PROFIL_CHOISI = 2  # Par dÃ©faut ("2" = ModÃ©rÃ©)

# DÃ©finition des profils prÃ©dÃ©finis
profils = {
    1: {
        'nom': 'CONSERVATEUR',
        'sma_short_range': range(50, 101, 10),
        'sma_long_range': range(200, 301, 20),
        'n_lags_regression': 10,
        'n_clusters_kmeans': 2,
        'description': 'StratÃ©gies Ã  faible volatilitÃ©, rÃ©action lente aux changements de marchÃ©'
    },
    2: {
        'nom': 'MODÃ‰RÃ‰',
        'sma_short_range': range(30, 71, 5),
        'sma_long_range': range(150, 281, 10),
        'n_lags_regression': 7,
        'n_clusters_kmeans': 3,
        'description': 'Ã‰quilibre entre rÃ©activitÃ© et stabilitÃ©'
    },
    3: {
        'nom': 'DYNAMIQUE',
        'sma_short_range': range(10, 51, 5),
        'sma_long_range': range(100, 201, 10),
        'n_lags_regression': 5,
        'n_clusters_kmeans': 4,
        'description': 'StratÃ©gies rÃ©actives, plus de signaux de trading'
    }
}

# --- Cas du profil 4 : entrÃ©e manuelle ---
if PROFIL_CHOISI == 4:
    print("Mode personnalisÃ© activÃ©Â :")
    # Saisie paramÃ¨tres personnalisÃ©s par l'utilisateur

    try:
        sma_short_deb = int(input("DÃ©but de la plage du SMA court (ex: 10) : "))
        sma_short_fin = int(input("Fin de la plage du SMA court (ex: 50) : "))
        sma_short_pas = int(input("Pas du SMA court (ex: 5) : "))

        sma_long_deb = int(input("DÃ©but de la plage du SMA long (ex: 100) : "))
        sma_long_fin = int(input("Fin de la plage du SMA long (ex: 200) : "))
        sma_long_pas = int(input("Pas du SMA long (ex: 10) : "))

        n_lags_regression = int(input("Nombre de lags rÃ©gression OLS (ex: 5) : "))
        n_clusters_kmeans = int(input("Nombre de clusters K-means (ex: 4) : "))
    except Exception as e:
        print("\nâš ï¸ ProblÃ¨me de saisie. Valeurs par dÃ©faut utilisÃ©es !\n", e)
        sma_short_deb, sma_short_fin, sma_short_pas = 10, 51, 5
        sma_long_deb, sma_long_fin, sma_long_pas = 100, 201, 10
        n_lags_regression, n_clusters_kmeans = 5, 4

    profil = {
        'nom': 'PERSONNALISÃ‰',
        'sma_short_range': range(sma_short_deb, sma_short_fin, sma_short_pas),
        'sma_long_range': range(sma_long_deb, sma_long_fin, sma_long_pas),
        'n_lags_regression': n_lags_regression,
        'n_clusters_kmeans': n_clusters_kmeans,
        'description': 'ParamÃ¨tres dÃ©finis manuellement'
    }

else:
    # Profils standard 1-2-3
    profil = profils[PROFIL_CHOISI]

print(f"âœ… Profil sÃ©lectionnÃ©: {profil['nom']}")
print(f"   Description: {profil['description']}")
print()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 4: OPTIMISATION DES PARAMÃˆTRES SMA
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("=" * 80)
print("  OPTIMISATION DES PARAMÃˆTRES SMA")
print("=" * 80)
print()

print(f"ğŸ” Recherche des meilleurs paramÃ¨tres SMA pour profil {profil['nom']}...")
print(f"   Plage SMA court: {profil['sma_short_range'].start} - {profil['sma_short_range'].stop-1}")
print(f"   Plage SMA long: {profil['sma_long_range'].start} - {profil['sma_long_range'].stop-1}")
print()

# Optimisation
optimization_results = pd.DataFrame()

for SMA1, SMA2 in product(profil['sma_short_range'], profil['sma_long_range']):
    if SMA1 >= SMA2:
        continue

    temp_data = data_original.copy()
    temp_data['SMA_Short'] = temp_data['Close'].rolling(SMA1).mean()
    temp_data['SMA_Long'] = temp_data['Close'].rolling(SMA2).mean()
    temp_data.dropna(inplace=True)

    temp_data['Position'] = np.where(temp_data['SMA_Short'] > temp_data['SMA_Long'], 1, -1)
    temp_data['Returns'] = np.log(temp_data['Close'] / temp_data['Close'].shift(1))
    temp_data['Strategy'] = temp_data['Position'].shift(1) * temp_data['Returns']
    temp_data.dropna(inplace=True)

    perf = np.exp(temp_data[['Returns', 'Strategy']].sum())
    volatility = temp_data['Strategy'].std() * np.sqrt(252)
    sharpe = (temp_data['Strategy'].mean() * 252) / volatility if volatility > 0 else 0
    n_trades = temp_data['Position'].diff().ne(0).sum()

    result = pd.DataFrame({
        'SMA_Short': [SMA1],
        'SMA_Long': [SMA2],
        'Market_Return': [perf['Returns']],
        'Strategy_Return': [perf['Strategy']],
        'Outperformance': [perf['Strategy'] - perf['Returns']],
        'Volatility': [volatility],
        'Sharpe_Ratio': [sharpe],
        'N_Trades': [n_trades]
    })

    optimization_results = pd.concat([optimization_results, result], ignore_index=True)

# Tri par Sharpe Ratio (meilleur indicateur risque/rendement)
optimization_results.sort_values('Sharpe_Ratio', ascending=False, inplace=True)

print(f"âœ… {len(optimization_results)} combinaisons testÃ©es")
print()
print("ğŸ† TOP 10 DES MEILLEURES COMBINAISONS (par Sharpe Ratio):")
print("-" * 80)
print(optimization_results.head(10).to_string(index=False))
print()

# Meilleurs paramÃ¨tres
best_params = optimization_results.iloc[0]
SMA_SHORT_OPT = int(best_params['SMA_Short'])
SMA_LONG_OPT = int(best_params['SMA_Long'])

print(f"â­ PARAMÃˆTRES OPTIMAUX SÃ‰LECTIONNÃ‰S:")
print(f"   - SMA Court: {SMA_SHORT_OPT} jours")
print(f"   - SMA Long: {SMA_LONG_OPT} jours")
print(f"   - Performance StratÃ©gie: {best_params['Strategy_Return']:.4f}x ({(best_params['Strategy_Return']-1)*100:.2f}%)")
print(f"   - Sharpe Ratio: {best_params['Sharpe_Ratio']:.4f}")
print(f"   - Nombre de trades: {int(best_params['N_Trades'])}")
print()

# Visualisation interactive de l'optimisation
fig_opt = go.Figure()

# Surface 3D : SMA_Short vs SMA_Long vs Sharpe_Ratio
fig_opt = go.Figure(data=[go.Scatter3d(
    x=optimization_results['SMA_Short'],
    y=optimization_results['SMA_Long'],
    z=optimization_results['Sharpe_Ratio'],
    mode='markers',
    marker=dict(
        size=5,
        color=optimization_results['Sharpe_Ratio'],
        colorscale='Viridis',
        showscale=True,
        colorbar=dict(title="Sharpe Ratio")
    ),
    text=[f"SMA: {s}/{l}<br>Sharpe: {sr:.3f}<br>Perf: {(p-1)*100:.2f}%"
          for s, l, sr, p in zip(optimization_results['SMA_Short'],
                                  optimization_results['SMA_Long'],
                                  optimization_results['Sharpe_Ratio'],
                                  optimization_results['Strategy_Return'])],
    hovertemplate='%{text}<extra></extra>'
)])

fig_opt.update_layout(
    title=f'Optimisation SMA - Profil {profil["nom"]}: Sharpe Ratio selon les paramÃ¨tres',
    scene=dict(
        xaxis_title='SMA Court (jours)',
        yaxis_title='SMA Long (jours)',
        zaxis_title='Sharpe Ratio'
    ),
    height=700
)

fig_opt.show()
print("ğŸ“Š Graphique interactif: Surface d'optimisation 3D gÃ©nÃ©rÃ©e")
print()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 5: STRATÃ‰GIE SMA OPTIMISÃ‰E
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("=" * 80)
print(f"  STRATÃ‰GIE SMA OPTIMISÃ‰E (SMA {SMA_SHORT_OPT}/{SMA_LONG_OPT})")
print("=" * 80)
print()

# Application des paramÃ¨tres optimaux
data_sma = data_original.copy()
data_sma['SMA_Short'] = data_sma['Close'].rolling(SMA_SHORT_OPT).mean()
data_sma['SMA_Long'] = data_sma['Close'].rolling(SMA_LONG_OPT).mean()
data_sma.dropna(inplace=True)
data_sma['Position'] = np.where(data_sma['SMA_Short'] > data_sma['SMA_Long'], 1, -1)

print(f"ğŸ“Š ParamÃ¨tres SMA optimaux appliquÃ©s:")
print(f"   - SMA court terme: {SMA_SHORT_OPT} jours")
print(f"   - SMA long terme: {SMA_LONG_OPT} jours")
print(f"   - Nombre de changements de position: {data_sma['Position'].diff().ne(0).sum()}")
print()

# Visualisation interactive des SMAs et positions
fig_sma = make_subplots(
    rows=2, cols=1,
    shared_xaxes=True,
    vertical_spacing=0.05,
    subplot_titles=(f'Prix Nintendo et SMAs OptimisÃ©es ({SMA_SHORT_OPT}/{SMA_LONG_OPT})',
                    'Signaux de Trading'),
    row_heights=[0.7, 0.3]
)

# Graphique 1: Prix et SMAs
fig_sma.add_trace(
    go.Scatter(x=data_sma.index, y=data_sma['Close'],
               name='Prix Nintendo', line=dict(color='blue', width=2)),
    row=1, col=1
)
fig_sma.add_trace(
    go.Scatter(x=data_sma.index, y=data_sma['SMA_Short'],
               name=f'SMA {SMA_SHORT_OPT}j', line=dict(color='orange', width=1.5)),
    row=1, col=1
)
fig_sma.add_trace(
    go.Scatter(x=data_sma.index, y=data_sma['SMA_Long'],
               name=f'SMA {SMA_LONG_OPT}j', line=dict(color='red', width=1.5)),
    row=1, col=1
)

# Graphique 2: Positions (Long/Short)
colors = ['green' if pos > 0 else 'red' for pos in data_sma['Position']]
fig_sma.add_trace(
    go.Scatter(x=data_sma.index, y=data_sma['Position'],
               name='Position', mode='lines',
               line=dict(color='darkblue', width=2),
               fill='tozeroy', fillcolor='rgba(0,100,80,0.2)'),
    row=2, col=1
)

fig_sma.update_xaxes(title_text="Date", row=2, col=1)
fig_sma.update_yaxes(title_text="Prix ($)", row=1, col=1)
fig_sma.update_yaxes(title_text="Position", row=2, col=1)

fig_sma.update_layout(
    height=800,
    title_text=f"StratÃ©gie SMA OptimisÃ©e - Profil {profil['nom']}",
    hovermode='x unified'
)

fig_sma.show()
print("ğŸ“Š Graphique interactif: SMAs et signaux de trading gÃ©nÃ©rÃ©s")
print()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 6: VECTORIZED BACKTESTING
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("=" * 80)
print("  BACKTESTING VECTORISÃ‰ - COMPARAISON BUY & HOLD VS SMA")
print("=" * 80)
print()

# Calcul des rendements
data_sma['Returns'] = np.log(data_sma['Close'] / data_sma['Close'].shift(1))
data_sma['Strategy'] = data_sma['Position'].shift(1) * data_sma['Returns']
data_sma.dropna(inplace=True)

# MÃ©triques de performance
cumulative_returns = np.exp(data_sma[['Returns', 'Strategy']].sum())
annualized_volatility = data_sma[['Returns', 'Strategy']].std() * np.sqrt(252)
sharpe_ratio = (data_sma[['Returns', 'Strategy']].mean() * 252) / annualized_volatility

years = (data_sma.index[-1] - data_sma.index[0]).days / 365.25
annual_return_bh = (cumulative_returns['Returns'] ** (1/years)) - 1
annual_return_strat = (cumulative_returns['Strategy'] ** (1/years)) - 1

# Calcul du Maximum Drawdown
def calculate_max_drawdown(returns):
    cum_returns = (1 + returns).cumprod()
    running_max = cum_returns.cummax()
    drawdown = (cum_returns - running_max) / running_max
    return drawdown.min()

max_dd_bh = calculate_max_drawdown(np.exp(data_sma['Returns']) - 1)
max_dd_strat = calculate_max_drawdown(np.exp(data_sma['Strategy']) - 1)

print("ğŸ“Š RÃ‰SULTATS DU BACKTESTING:")
print("-" * 80)
print(f"{'MÃ©trique':<40} {'Buy & Hold':<20} {'SMA Strategy':<20}")
print("-" * 80)
print(f"{'Performance cumulÃ©e':<40} {cumulative_returns['Returns']:<20.4f} {cumulative_returns['Strategy']:<20.4f}")
print(f"{'Performance %':<40} {(cumulative_returns['Returns']-1)*100:<20.2f}% {(cumulative_returns['Strategy']-1)*100:<20.2f}%")
print(f"{'Rendement annuel moyen':<40} {annual_return_bh*100:<20.2f}% {annual_return_strat*100:<20.2f}%")
print(f"{'VolatilitÃ© annualisÃ©e':<40} {annualized_volatility['Returns']:<20.4f} {annualized_volatility['Strategy']:<20.4f}")
print(f"{'Sharpe Ratio (sans rf)':<40} {sharpe_ratio['Returns']:<20.4f} {sharpe_ratio['Strategy']:<20.4f}")
print(f"{'Maximum Drawdown':<40} {max_dd_bh*100:<20.2f}% {max_dd_strat*100:<20.2f}%")
print(f"{'Nombre de trades':<40} {'-':<20} {int(data_sma['Position'].diff().ne(0).sum()):<20}")
print(f"{'DurÃ©e (annÃ©es)':<40} {years:<20.2f}")
print("-" * 80)
print()

# Visualisation interactive des performances
cumulative_perf = data_sma[['Returns', 'Strategy']].cumsum().apply(np.exp)

fig_backtest = go.Figure()

fig_backtest.add_trace(go.Scatter(
    x=cumulative_perf.index,
    y=cumulative_perf['Returns'],
    name='Buy & Hold',
    line=dict(color='blue', width=3)
))

fig_backtest.add_trace(go.Scatter(
    x=cumulative_perf.index,
    y=cumulative_perf['Strategy'],
    name='SMA Strategy',
    line=dict(color='green', width=3)
))

fig_backtest.add_hline(y=1, line_dash="dash", line_color="gray",
                       annotation_text="Investissement initial")

fig_backtest.update_layout(
    title=f'Performance Cumulative: Buy & Hold vs StratÃ©gie SMA OptimisÃ©e<br>Profil {profil["nom"]} - SMA {SMA_SHORT_OPT}/{SMA_LONG_OPT}',
    xaxis_title='Date',
    yaxis_title='Performance Cumulative',
    hovermode='x unified',
    height=600
)

fig_backtest.show()
print("ğŸ“Š Graphique interactif: Comparaison des performances gÃ©nÃ©rÃ©e")
print()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 7: STRATÃ‰GIE BASÃ‰E SUR LA RÃ‰GRESSION (OLS)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("=" * 80)
print("  STRATÃ‰GIE BASÃ‰E SUR LA RÃ‰GRESSION (OLS)")
print("=" * 80)
print()

# PrÃ©paration des donnÃ©es
data_regression = data_original.copy()
data_regression['returns'] = np.log(data_regression['Close'] / data_regression['Close'].shift(1))

# CrÃ©ation des lags selon le profil
lags = profil['n_lags_regression']
cols = []
for lag in range(1, lags + 1):
    col = f'lag_{lag}'
    data_regression[col] = data_regression['returns'].shift(lag)
    cols.append(col)

data_regression.dropna(inplace=True)
data_regression['direction'] = np.sign(data_regression['returns']).astype(int)

print(f"ğŸ“Š RÃ©gression OLS avec {lags} lags (profil {profil['nom']})")
print(f"   Nombre d'observations: {len(data_regression)}")
print()

# ModÃ¨le 1: RÃ©gression sur les rendements
model_returns = LinearRegression()
data_regression['pred_returns'] = model_returns.fit(
    data_regression[cols],
    data_regression['returns']
).predict(data_regression[cols])

# ModÃ¨le 2: RÃ©gression sur la direction
model_direction = LinearRegression()
data_regression['pred_direction'] = model_direction.fit(
    data_regression[cols],
    data_regression['direction']
).predict(data_regression[cols])

# Positions de trading
data_regression['pos_reg_returns'] = np.where(data_regression['pred_returns'] > 0, 1, -1)
data_regression['pos_reg_direction'] = np.where(data_regression['pred_direction'] > 0, 1, -1)

# StratÃ©gies
data_regression['strat_reg_returns'] = data_regression['pos_reg_returns'] * data_regression['returns']
data_regression['strat_reg_direction'] = data_regression['pos_reg_direction'] * data_regression['returns']

# Performances
perf_regression = np.exp(data_regression[['returns', 'strat_reg_returns', 'strat_reg_direction']].sum())
accuracy_returns = (data_regression['direction'] == data_regression['pos_reg_returns']).sum() / len(data_regression)
accuracy_direction = (data_regression['direction'] == data_regression['pos_reg_direction']).sum() / len(data_regression)

print("ğŸ“Š RÃ‰SULTATS DES STRATÃ‰GIES DE RÃ‰GRESSION:")
print("-" * 80)
print(f"{'StratÃ©gie':<40} {'Performance':<20} {'% Gain':<20}")
print("-" * 80)
print(f"{'Buy & Hold':<40} {perf_regression['returns']:<20.4f} {(perf_regression['returns']-1)*100:<20.2f}%")
print(f"{'RÃ©gression sur Rendements':<40} {perf_regression['strat_reg_returns']:<20.4f} {(perf_regression['strat_reg_returns']-1)*100:<20.2f}%")
print(f"{'RÃ©gression sur Direction':<40} {perf_regression['strat_reg_direction']:<20.4f} {(perf_regression['strat_reg_direction']-1)*100:<20.2f}%")
print("-" * 80)
print()
print(f"{'PrÃ©cision des PrÃ©dictions:':<40}")
print(f"{'  ModÃ¨le sur Rendements':<40} {accuracy_returns*100:<20.2f}%")
print(f"{'  ModÃ¨le sur Direction':<40} {accuracy_direction*100:<20.2f}%")
print()

# Visualisation interactive
cumulative_reg = data_regression[['returns', 'strat_reg_returns', 'strat_reg_direction']].cumsum().apply(np.exp)

fig_reg = go.Figure()

fig_reg.add_trace(go.Scatter(x=cumulative_reg.index, y=cumulative_reg['returns'],
                             name='Buy & Hold', line=dict(color='blue', width=2)))
fig_reg.add_trace(go.Scatter(x=cumulative_reg.index, y=cumulative_reg['strat_reg_returns'],
                             name='RÃ©gression Rendements', line=dict(color='orange', width=2)))
fig_reg.add_trace(go.Scatter(x=cumulative_reg.index, y=cumulative_reg['strat_reg_direction'],
                             name='RÃ©gression Direction', line=dict(color='green', width=2)))

fig_reg.update_layout(
    title=f'Performances des StratÃ©gies de RÃ©gression OLS<br>Profil {profil["nom"]} - {lags} lags',
    xaxis_title='Date',
    yaxis_title='Performance Cumulative',
    hovermode='x unified',
    height=600
)

fig_reg.show()
print("ğŸ“Š Graphique interactif: Performances rÃ©gression gÃ©nÃ©rÃ©es")
print()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 8: K-MEANS CLUSTERING AMÃ‰LIORÃ‰ (MACHINE LEARNING)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("=" * 80)
print("  K-MEANS CLUSTERING AMÃ‰LIORÃ‰ (MACHINE LEARNING)")
print("=" * 80)
print()

# PrÃ©paration des features enrichies
data_ml = data_regression[cols + ['returns', 'direction']].copy()

# Ajout de features techniques supplÃ©mentaires
data_ml['volatility_5'] = data_regression['returns'].rolling(5).std()
data_ml['volatility_20'] = data_regression['returns'].rolling(20).std()
data_ml['momentum_5'] = data_regression['returns'].rolling(5).mean()
data_ml['momentum_20'] = data_regression['returns'].rolling(20).mean()

data_ml.dropna(inplace=True)

# Standardisation des features
scaler = StandardScaler()
features_for_clustering = cols + ['volatility_5', 'volatility_20', 'momentum_5', 'momentum_20']
scaled_features = scaler.fit_transform(data_ml[features_for_clustering])

# Application du K-means
n_clusters = profil['n_clusters_kmeans']
kmeans = KMeans(n_clusters=n_clusters, random_state=42, n_init=10)
data_ml['cluster'] = kmeans.fit_predict(scaled_features)

print(f"ğŸ“Š K-Means Clustering avec {n_clusters} clusters (profil {profil['nom']})")
print(f"   Features utilisÃ©es: {len(features_for_clustering)} (lags + volatilitÃ© + momentum)")
print()

# Analyse des clusters pour dÃ©terminer les positions
cluster_returns = data_ml.groupby('cluster')['returns'].mean()
print("ğŸ“Š Rendements moyens par cluster:")
for cluster, ret in cluster_returns.items():
    print(f"   Cluster {cluster}: {ret*100:.4f}% {'(Favorable)' if ret > 0 else '(DÃ©favorable)'}")
print()

# Attribution des positions selon la performance des clusters
# Les clusters avec rendements positifs â†’ Long (1)
# Les clusters avec rendements nÃ©gatifs â†’ Short (-1)
cluster_to_position = {cluster: (1 if ret > 0 else -1)
                       for cluster, ret in cluster_returns.items()}

data_ml['pos_cluster'] = data_ml['cluster'].map(cluster_to_position)
data_ml['strat_cluster'] = data_ml['pos_cluster'] * data_ml['returns']

# Performance
perf_cluster = np.exp(data_ml[['returns', 'strat_cluster']].sum())
accuracy_cluster = (data_ml['direction'] == data_ml['pos_cluster']).sum() / len(data_ml)
n_trades_cluster = data_ml['pos_cluster'].diff().ne(0).sum()

print("ğŸ“Š RÃ‰SULTATS DU K-MEANS CLUSTERING:")
print("-" * 80)
print(f"{'StratÃ©gie':<40} {'Performance':<20} {'% Gain':<20}")
print("-" * 80)
print(f"{'Buy & Hold':<40} {perf_cluster['returns']:<20.4f} {(perf_cluster['returns']-1)*100:<20.2f}%")
print(f"{'K-Means Strategy':<40} {perf_cluster['strat_cluster']:<20.4f} {(perf_cluster['strat_cluster']-1)*100:<20.2f}%")
print("-" * 80)
print()
print(f"{'PrÃ©cision des PrÃ©dictions:':<40} {accuracy_cluster*100:<20.2f}%")
print(f"{'Nombre de trades:':<40} {n_trades_cluster:<20}")
print()

# Visualisation interactive des clusters
fig_clusters = make_subplots(
    rows=1, cols=2,
    subplot_titles=('Distribution des Clusters (Lag 1 vs Lag 2)',
                    'Performance K-Means Strategy'),
    specs=[[{"type": "scatter"}, {"type": "scatter"}]]
)

# Scatter plot des clusters
for cluster in range(n_clusters):
    cluster_data = data_ml[data_ml['cluster'] == cluster]
    fig_clusters.add_trace(
        go.Scatter(
            x=cluster_data['lag_1'],
            y=cluster_data['lag_2'],
            mode='markers',
            name=f'Cluster {cluster}',
            marker=dict(size=5, opacity=0.6)
        ),
        row=1, col=1
    )

# Performance cumulative
cumulative_cluster = data_ml[['returns', 'strat_cluster']].cumsum().apply(np.exp)

fig_clusters.add_trace(
    go.Scatter(x=cumulative_cluster.index, y=cumulative_cluster['returns'],
               name='Buy & Hold', line=dict(color='blue', width=2)),
    row=1, col=2
)
fig_clusters.add_trace(
    go.Scatter(x=cumulative_cluster.index, y=cumulative_cluster['strat_cluster'],
               name='K-Means Strategy', line=dict(color='purple', width=2)),
    row=1, col=2
)

fig_clusters.update_xaxes(title_text="Lag 1 (Rendement J-1)", row=1, col=1)
fig_clusters.update_yaxes(title_text="Lag 2 (Rendement J-2)", row=1, col=1)
fig_clusters.update_xaxes(title_text="Date", row=1, col=2)
fig_clusters.update_yaxes(title_text="Performance Cumulative", row=1, col=2)

fig_clusters.update_layout(
    title_text=f"K-Means Clustering Strategy - Profil {profil['nom']} ({n_clusters} clusters)",
    height=500,
    showlegend=True
)

fig_clusters.show()
print("ğŸ“Š Graphique interactif: Clusters et performance gÃ©nÃ©rÃ©s")
print()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 9: TABLEAU RÃ‰CAPITULATIF ET RECOMMANDATIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("=" * 80)
print("  TABLEAU RÃ‰CAPITULATIF - TOUTES LES STRATÃ‰GIES")
print("=" * 80)
print()

# Compilation des rÃ©sultats
summary = pd.DataFrame({
    'StratÃ©gie': [
        'Buy & Hold',
        f'SMA OptimisÃ©e ({SMA_SHORT_OPT}/{SMA_LONG_OPT})',
        f'RÃ©gression Rendements ({lags} lags)',
        f'RÃ©gression Direction ({lags} lags)',
        f'K-Means Clustering ({n_clusters} clusters)'
    ],
    'Performance Cumulative': [
        cumulative_returns['Returns'],
        cumulative_returns['Strategy'],
        perf_regression['strat_reg_returns'],
        perf_regression['strat_reg_direction'],
        perf_cluster['strat_cluster']
    ],
    'Performance %': [
        (cumulative_returns['Returns']-1)*100,
        (cumulative_returns['Strategy']-1)*100,
        (perf_regression['strat_reg_returns']-1)*100,
        (perf_regression['strat_reg_direction']-1)*100,
        (perf_cluster['strat_cluster']-1)*100
    ],
    'VolatilitÃ©': [
        annualized_volatility['Returns'],
        annualized_volatility['Strategy'],
        data_regression['strat_reg_returns'].std() * np.sqrt(252),
        data_regression['strat_reg_direction'].std() * np.sqrt(252),
        data_ml['strat_cluster'].std() * np.sqrt(252)
    ],
    'Sharpe Ratio': [
        sharpe_ratio['Returns'],
        sharpe_ratio['Strategy'],
        (data_regression['strat_reg_returns'].mean() * 252) / (data_regression['strat_reg_returns'].std() * np.sqrt(252)),
        (data_regression['strat_reg_direction'].mean() * 252) / (data_regression['strat_reg_direction'].std() * np.sqrt(252)),
        (data_ml['strat_cluster'].mean() * 252) / (data_ml['strat_cluster'].std() * np.sqrt(252))
    ],
    'Nombre de Trades': [
        0,
        int(data_sma['Position'].diff().ne(0).sum()),
        int(data_regression['pos_reg_returns'].diff().ne(0).sum()),
        int(data_regression['pos_reg_direction'].diff().ne(0).sum()),
        int(n_trades_cluster)
    ]
})

summary['Gain vs Buy&Hold %'] = summary['Performance %'] - summary['Performance %'].iloc[0]

print(summary.to_string(index=False))
print()

# Visualisation comparative finale
fig_final = go.Figure()

strategies = summary['StratÃ©gie'].tolist()
performances = summary['Performance %'].tolist()
colors_bar = ['blue', 'green', 'orange', 'red', 'purple']

fig_final.add_trace(go.Bar(
    x=strategies,
    y=performances,
    marker_color=colors_bar,
    text=[f'{p:.2f}%' for p in performances],
    textposition='outside'
))

fig_final.update_layout(
    title=f'Comparaison des Performances - Profil {profil["nom"]}',
    xaxis_title='StratÃ©gie',
    yaxis_title='Performance (%)',
    height=600,
    showlegend=False
)

fig_final.show()
print("ğŸ“Š Graphique interactif: Comparaison finale gÃ©nÃ©rÃ©e")
print()

# Recommandations
print("=" * 80)
print("  RECOMMANDATIONS POUR L'INVESTISSEUR")
print("=" * 80)
print()

best_strategy_idx = summary['Sharpe Ratio'].iloc[1:].idxmax()
best_strategy = summary.loc[best_strategy_idx]

print(f"ğŸ¯ MEILLEURE STRATÃ‰GIE pour profil {profil['nom']}: {best_strategy['StratÃ©gie']}")
print(f"   â”œâ”€ Performance: {best_strategy['Performance Cumulative']:.4f}x ({best_strategy['Performance %']:.2f}%)")
print(f"   â”œâ”€ Surperformance vs Buy&Hold: {best_strategy['Gain vs Buy&Hold %']:.2f}%")
print(f"   â”œâ”€ Sharpe Ratio: {best_strategy['Sharpe Ratio']:.4f}")
print(f"   â”œâ”€ VolatilitÃ© annualisÃ©e: {best_strategy['VolatilitÃ©']:.4f}")
print(f"   â””â”€ Nombre de trades: {int(best_strategy['Nombre de Trades'])}")
print()

print("ğŸ’¡ CONSEILS D'INVESTISSEMENT:")
print(f"   1. Pour un profil {profil['nom']}, la stratÃ©gie recommandÃ©e offre un bon Ã©quilibre risque/rendement")
print(f"   2. La stratÃ©gie SMA optimisÃ©e ({SMA_SHORT_OPT}/{SMA_LONG_OPT}) est robuste et facile Ã  implÃ©menter")
print(f"   3. Les stratÃ©gies de Machine Learning offrent de la diversification")
print(f"   4. Toujours considÃ©rer les coÃ»ts de transaction dans l'implÃ©mentation rÃ©elle")
print(f"   5. Ces rÃ©sultats sont basÃ©s sur des donnÃ©es historiques - les performances passÃ©es ne garantissent pas les performances futures")
print()

print("=" * 80)
print("  FIN DE L'ANALYSE - ALGORITHMIC TRADING")
print("=" * 80)
