# -*- coding: utf-8 -*-
"""Projet-final-Nintendo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DFbzRpkYmt6vzG4kHRCkDku6DtUn4Z9J
"""

# ==========================================
# Nintendo portfolio - Outils & mod√®les
# ==========================================
# - M4 : Mean-Variance avec Nintendo √† poids fix√© (ton mod√®le de base)
# - HRP : Hierarchical Risk Parity (mod√®le de r√©f√©rence pour la reco)
# ==========================================

from __future__ import annotations
import warnings
from dataclasses import dataclass
from typing import List

import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt

# HRP : clustering hi√©rarchique
from scipy.cluster.hierarchy import linkage, leaves_list
from scipy.spatial.distance import squareform

# cvxpy optionnel (QP). Fallback pr√©vu si absent.
try:
    import cvxpy as cp
    HAS_CVXPY = True
except Exception:
    HAS_CVXPY = False

warnings.filterwarnings("ignore")

# -------------------------------------
# Config de base
# -------------------------------------
NINTENDO = "NTDOY"  # Nintendo (ADR US)
DEFAULT_PEERS = ["EA", "TTWO", "SONY", "MSFT",
                 "7832.T", "9697.T", "9684.T", "9766.T",
                 "UBI.PA", "TCEHY"]
START, END = "2015-09-30", "2025-09-30"

TICKER_NAME = {
    "NTDOY": "Nintendo (ADR)",
    "7974.T": "Nintendo (Tokyo)",
    "EA": "Electronic Arts",
    "TTWO": "Take-Two Interactive",
    "SONY": "Sony Group (ADR)",
    "MSFT": "Microsoft",
    "7832.T": "Bandai Namco",
    "9697.T": "Capcom",
    "9684.T": "Square Enix",
    "9766.T": "Konami",
    "UBI.PA": "Ubisoft",
    "TCEHY": "Tencent (ADR)",
}

ORDER = "asc"  # tri d'affichage


# -------------------------------------
# Fonctions d'entr√©e utilisateur (pour la boucle simul)
# -------------------------------------
def ask_float_pct(msg: str, default: float, lo: float = 0.0, hi: float = 1.0) -> float:
    """Demande un pourcentage lisible (6, 6%, 0.06). Renvoie un float dans [0..1]."""
    while True:
        s = input(f"{msg} [{int(default*100)}%]: ").strip().lower()
        if not s:
            return default
        try:
            s = s.replace(",", ".")
            if s.endswith("%"):
                x = float(s[:-1]) / 100
            else:
                x = float(s)
                if x > 1:
                    x = x / 100
        except ValueError:
            print("‚Üí Merci d'entrer un nombre (ex: 6, 6%, 0.06).")
            continue
        if lo <= x <= hi:
            return x
        print(f"‚Üí Le pourcentage doit √™tre entre {lo:.0%} et {hi:.0%}.")


def ask_int(msg: str, default: int, lo: int = 1, hi: int = 20) -> int:
    """Demande un entier (ex: ann√©es)."""
    while True:
        s = input(f"{msg} [{default}]: ").strip()
        if not s:
            return default
        if s.isdigit():
            x = int(s)
            if lo <= x <= hi:
                return x
        print(f"‚Üí Entrer un entier entre {lo} et {hi}.")


# -------------------------------------
# Donn√©es Yahoo & m√©triques
# -------------------------------------
def download_prices(tickers: List[str], start: str, end: str) -> pd.DataFrame:
    data = yf.download(tickers, start=start, end=end,
                       progress=False, auto_adjust=True)
    if isinstance(data.columns, pd.MultiIndex):
        data = data["Close"]
    return data.ffill().dropna()


def pct_returns(prices: pd.DataFrame) -> pd.DataFrame:
    return prices.pct_change().dropna()


def ann_perf(r: pd.Series):
    """Retourne (rendement annuel, vol annuelle, Sharpe) sur une s√©rie de rendements quotidiens."""
    ann_ret = (1 + r).prod()**(252/len(r)) - 1
    ann_vol = r.std() * np.sqrt(252)
    sharpe = ann_ret / (ann_vol + 1e-12)
    return ann_ret, ann_vol, sharpe


# Petit utilitaire pour √©valuer un portefeuille complet
def evaluate_portfolio(weights: pd.Series, returns: pd.DataFrame):
    weights = weights / weights.sum()
    common = [t for t in weights.index if t in returns.columns]
    port_rets = (returns[common] * weights[common]).sum(axis=1)
    ann_ret, ann_vol, sharpe = ann_perf(port_rets)
    growth = (1 + port_rets).cumprod()
    return ann_ret, ann_vol, sharpe, port_rets, growth


# -------------------------------------
# Contraintes & optimisation MV (ton M4)
# -------------------------------------
@dataclass
class Constraints:
    min_center_weight: float = 0.10
    max_center_weight: float = 0.80
    max_weight_per_name: float = 0.25


cons = Constraints()


def optimize_mv_centered(mu: pd.Series, cov: pd.DataFrame,
                         tickers: List[str],
                         center: str,
                         cons: Constraints,
                         target_center_weight: float) -> pd.Series:
    """
    Optimisation moyenne-variance avec poids FIXE sur Nintendo.
    (Ton mod√®le de base - M4)
    """
    n = len(tickers)
    if not HAS_CVXPY:
        # Fallback simple : poids Nintendo fix√©, reste en √©quipond√©r√©
        weights = pd.Series(0.0, index=tickers)
        weights[center] = target_center_weight
        others = [t for t in tickers if t != center]
        rest = 1.0 - weights.sum()
        if rest < 0:
            raise RuntimeError("Poids Nintendo trop √©lev√© pour la heuristique.")
        if others:
            weights[others] = rest / len(others)
        return weights

    w = cp.Variable(n)
    idx_center = tickers.index(center)

    Sigma = cov.loc[tickers, tickers].values
    Sigma = 0.5 * (Sigma + Sigma.T)
    eps = 1e-6 * np.mean(np.diag(Sigma))
    np.fill_diagonal(Sigma, np.diag(Sigma) + eps)
    gamma = 10.0 / max(np.trace(Sigma), 1e-8)

    constraints = [cp.sum(w) == 1.0, w >= 0]
    for i in range(n):
        if i != idx_center:
            constraints.append(w[i] <= cons.max_weight_per_name)
    constraints.append(w[idx_center] == target_center_weight)

    objective = cp.Maximize(mu.loc[tickers].values @ w
                            - 0.5 * gamma * cp.quad_form(w, Sigma))
    prob = cp.Problem(objective, constraints)
    try:
        prob.solve(solver=cp.OSQP, verbose=False)
    except Exception:
        prob.solve(solver=cp.SCS, verbose=False)

    if w.value is None:
        raise RuntimeError("Optimisation MV centr√©e Nintendo impossible.")

    wv = np.array(w.value).ravel()
    wv = wv / wv.sum()
    return pd.Series(wv, index=tickers)


# -------------------------------------
# Mod√®le HRP (Hierarchical Risk Parity)
# -------------------------------------
def _correl_dist(corr: pd.DataFrame) -> np.ndarray:
    """Distance de corr√©lation pour HRP."""
    return np.sqrt(0.5 * (1 - corr))


def _get_cluster_var(cov: pd.DataFrame, items: List[str]) -> float:
    sub = cov.loc[items, items]
    w = np.ones(len(sub)) / len(sub)
    return float(w @ sub.values @ w)


def build_hrp_weights(returns: pd.DataFrame) -> pd.Series:
    """
    Impl√©mentation simple de HRP (Lopez de Prado) :
    - clustering hi√©rarchique sur les corr√©lations
    - allocation par bisection r√©cursive
    """
    corr = returns.corr()
    cov = returns.cov()

    # Distance de corr√©lation -> matrice condens√©e pour linkage
    dist = _correl_dist(corr)
    dist_cond = squareform(dist.values, checks=False)

    # Clustering hi√©rarchique
    link = linkage(dist_cond, method="single")
    sort_idx = leaves_list(link)
    ordered_tickers = corr.index[sort_idx].tolist()

    # Bisection r√©cursive
    weights = pd.Series(1.0, index=ordered_tickers)
    clusters = [ordered_tickers]

    while clusters:
        cluster = clusters.pop(0)
        if len(cluster) <= 1:
            continue

        split = len(cluster) // 2
        c1 = cluster[:split]
        c2 = cluster[split:]

        var1 = _get_cluster_var(cov, c1)
        var2 = _get_cluster_var(cov, c2)
        # allocation inversement proportionnelle au risque
        alloc2 = var1 / (var1 + var2)
        alloc1 = 1.0 - alloc2

        weights[c1] *= alloc1
        weights[c2] *= alloc2

        clusters.append(c1)
        clusters.append(c2)

    # Remettre dans l'ordre original des colonnes de returns
    weights = weights.reindex(returns.columns)
    weights = weights / weights.sum()
    return weights


# -------------------------------------
# Donn√©es communes pour tout le notebook
# -------------------------------------
UNIVERSE = [NINTENDO] + DEFAULT_PEERS
PRICES = download_prices(UNIVERSE, START, END)
RETURNS = pct_returns(PRICES)

TICKERS = list(RETURNS.columns)
if NINTENDO in TICKERS:
    CENTER = NINTENDO
elif "7974.T" in TICKERS:
    CENTER = "7974.T"
else:
    CENTER = TICKERS[0]

MU_ANN = RETURNS.mean() * 252
COV_ANN = RETURNS.cov() * 252

# Poids recommand√©s par le mod√®le HRP (m√©thode alternative)
HRP_WEIGHTS = build_hrp_weights(RETURNS)
HRP_WEIGHTS = HRP_WEIGHTS / HRP_WEIGHTS.sum()  # normalisation de s√©curit√©

# ==========================================
# BOUCLE R√âP√âT√âE ‚Äì Simulateur interactif (M4) + HRP
# ==========================================
import time, sys

def herfindahl(w: pd.Series) -> float:
    """Indice de concentration simple (HHI)."""
    w = w / w.sum()
    return float((w**2).sum())

while True:

    print("""
üëã Nouvelle configuration de portefeuille centr√©e sur Nintendo.

Cette simulation utilise une optimisation moyenne-variance (M4)
avec un poids FIXE sur Nintendo que tu choisis toi-m√™me.

En compl√©ment, nous affichons aussi l'allocation recommand√©e
par un mod√®le alternatif : Hierarchical Risk Parity (HRP).
""")

    # ======= QUESTIONS INVESTISSEUR =======
    target_return = ask_float_pct("Quel rendement annuel vises-tu ?", 0.06, 0.0, 0.3)
    horizon_years = ask_int("Sur combien d'ann√©es envisages-tu d'investir ?", 3, 1, 20)
    nintendo_weight = ask_float_pct(
        "Quel pourcentage souhaites-tu allouer √† Nintendo ?",
        0.30,
        cons.min_center_weight,
        cons.max_center_weight,
    )

    # ======= DONN√âES (on r√©utilise celles calcul√©es dans la cellule 1) =======
    returns_sim = RETURNS
    prices_sim  = PRICES
    tickers_sim = TICKERS
    center_sim  = CENTER

    mu_ann_sim  = returns_sim.mean() * 252
    cov_ann_sim = returns_sim.cov() * 252

    # ======= OPTIMISATION M4 (MV centr√©e Nintendo) =======
    weights_m4 = optimize_mv_centered(
        mu_ann_sim,
        cov_ann_sim,
        tickers_sim,
        center_sim,
        cons,
        target_center_weight=nintendo_weight
    )

    ann_ret, ann_vol, sharpe, port_rets, growth_port = evaluate_portfolio(weights_m4, returns_sim)

    # ======= AFFICHAGE ALLOCATION M4 =======
    alloc_df = pd.DataFrame({"w": weights_m4})
    alloc_df["name"] = alloc_df.index.map(lambda t: TICKER_NAME.get(t, t))
    alloc_df = alloc_df.sort_values("w", ascending=(ORDER == "asc"))
    alloc_named = alloc_df.set_index("name")["w"]

    print("\nüßÆ Allocation finale (M4) avec Nintendo fix√© √†", f"{nintendo_weight:.0%}")
    print((alloc_named * 100).round(2).astype(str) + " %")

    print(f"\nüéØ R√©sultats estim√©s pour cette configuration (M4) :")
    print(f"  ‚Ä¢ Rendement annuel estim√© : {ann_ret:.2%}")
    print(f"  ‚Ä¢ Volatilit√© annuelle estim√©e : {ann_vol:.2%}")
    print(f"  ‚Ä¢ Ratio de Sharpe : {sharpe:.2f}")
    print(f"  ‚Ä¢ Horizon d'investissement d√©clar√© : {horizon_years} ans")

    # ======= HRP : ALLOCATION + PERF + ENCADR√â =======
    hrp_weights_full = HRP_WEIGHTS.reindex(tickers_sim).fillna(0)
    hrp_ret, hrp_vol, hrp_sharpe, _, _ = evaluate_portfolio(hrp_weights_full, returns_sim)
    hrp_named = hrp_weights_full.rename(index=lambda t: TICKER_NAME.get(t, t))

    hrp_nintendo = hrp_weights_full.get(center_sim, 0.0)
    m4_nintendo  = weights_m4.get(center_sim, 0.0)

    print("\n" + "‚ïê"*80)
    print(" Recommandation th√©orique ‚Äì HRP (Hierarchical Risk Parity)".center(80))
    print("‚ïê"*80)

    print((hrp_named * 100).round(2).astype(str) + " %")

    print(f"\n   ‚Üí Poids Nintendo recommand√© (HRP) : {hrp_nintendo:.1%}")
    print(f"   ‚Üí Poids Nintendo dans ta configuration M4 : {m4_nintendo:.1%}")

    print(f"\n   ‚Üí Rendement annuel estim√© (HRP)    : {hrp_ret:.2%}")
    print(f"   ‚Üí Volatilit√© annuelle estim√©e (HRP): {hrp_vol:.2%}")
    print(f"   ‚Üí Sharpe (HRP)                     : {hrp_sharpe:.2f}")
    print("‚ïê"*80)

    # ======= COMPARAISON AUTOMATIQUE M4 vs HRP =======
    print("\nüìå Comparaison M4 (ton portefeuille) vs HRP (r√©f√©rence neutre) :")
    print(f"   ‚Ä¢ M4  : rendement {ann_ret:.2%}, volatilit√© {ann_vol:.2%}, Sharpe {sharpe:.2f}")
    print(f"   ‚Ä¢ HRP : rendement {hrp_ret:.2%}, volatilit√© {hrp_vol:.2%}, Sharpe {hrp_sharpe:.2f}")

    hhi_m4  = herfindahl(weights_m4)
    hhi_hrp = herfindahl(hrp_weights_full)
    print(f"\n   ‚Ä¢ Indice de concentration (HHI) M4  : {hhi_m4:.3f}")
    print(f"   ‚Ä¢ Indice de concentration (HHI) HRP : {hhi_hrp:.3f}")

    if hrp_sharpe > sharpe:
        print("\n   ‚Üí HRP offre un meilleur couple rendement/risque (Sharpe plus √©lev√©).")
        print("     Il sacrifie √©ventuellement un peu de performance brute pour une meilleure efficacit√© ajust√©e du risque.")
    elif (hrp_vol < ann_vol) and (hrp_ret < ann_ret):
        print("\n   ‚Üí HRP propose un rendement plus faible, mais aussi une volatilit√© plus basse.")
        print("     C'est une allocation plus prudente et plus diversifi√©e, qui accepte de renoncer √† un peu de performance")
        print("     pour limiter les √†-coups et la concentration du risque.")
    else:
        print("\n   ‚Üí Ici, HRP sert surtout de point de rep√®re 'neutre' en risque.")
        print("     Ton portefeuille M4 refl√®te davantage ta pr√©f√©rence pour Nintendo et le profil de rendement que tu vises.")

    if hhi_hrp < hhi_m4:
        print("   ‚Üí HRP est aussi moins concentr√© : le risque est mieux r√©parti entre les titres.")
    else:
        print("   ‚Üí La concentration du portefeuille M4 est comparable √† celle de HRP sur cette simulation.")

    # ======= GRAPHIQUE : BARPLOT DES ALLOCATIONS M4 =======
    plt.figure(figsize=(8, 4))
    alloc_plot = alloc_df.sort_values("w", ascending=(ORDER == "asc"))
    plt.bar(
        alloc_plot["name"],
        alloc_plot["w"],
        edgecolor="black"
    )
    plt.xticks(rotation=45, ha="right")
    plt.title("Allocation du portefeuille propos√© (M4)")
    plt.ylabel("Poids (fraction du portefeuille)")
    plt.tight_layout()
    plt.show()

    # ======= QUESTION DE RELANCE (patch Colab) =======
    print("\n" + "="*80)
    time.sleep(0.3)
    sys.stdout.flush()

    rep = input("Souhaites-tu lancer une NOUVELLE simulation avec d‚Äôautres param√®tres ? [o/N]: ").strip().lower()
    if rep not in ("o", "oui", "y", "yes"):
        print("üëâ Fin des simulations.")
        break

    print("\n=== Nouvelle simulation ===\n")